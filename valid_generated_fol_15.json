[
    {
        "conclusion": "If Alex likes both Jane and Bob, then David is not a friend of Alex.",
        "conclusion_FOL": "Likes(alex, jane) ∧ Likes(alex, bob) → ¬FriendOf(david, alex) ::: If Alex likes both Jane and Bob, then David is not a friend of Alex.",
        "premises": [
            "Alex likes Jane and Alex likes Bob.",
            "Alex is not friends with anyone who hates Jane.",
            "Anyone who hates Jane hates Bob.",
            "If someone is a friend of Alex, then Alex is a friend of that person.",
            "If Alex loves someone, then Alex is not friends with that person.",
            "Alex studies at the university.",
            "Everyone at the university either likes Jane or hates Bob.",
            "If Alex hates Bob, then Alex is not friends with David.",
            "Alex is not friends with someone who likes Jane.",
            "Jane hates David.",
            "Anyone who hates Jane hates David.",
            "If someone loves Jane, then that person is not happy.",
            "If Alex is rich then Alex is not famous.",
            "Bob knows David.",
            "Alex knows someone who is happy and can sing."
        ],
        "premises_FOL": [
            "Likes(alex, jane) ∧ Likes(alex, bob) ::: Alex likes Jane and Alex likes Bob.",
            "¬FriendOf(alex, x) → ¬Hates(x, jane) ::: Alex is not friends with anyone who hates Jane.",
            "∀x (Hates(x, jane) → Hates(x, bob)) ::: Anyone who hates Jane hates Bob.",
            "∀x (FriendOf(x, alex) → FriendOf(alex, x)) ::: If someone is a friend of Alex, then Alex is a friend of that person.",
            "∀x (Loves(alex, x) → ¬FriendOf(alex, x)) ::: If Alex loves someone, then Alex is not friends with that person.",
            "Studies(alex, university) ::: Alex studies at the university.",
            "∀x (IsStudent(x, university) → Likes(x, jane) ∨ Hates(x, bob)) ::: Everyone at the university either likes Jane or hates Bob.",
            "Hates(alex, bob) → ¬FriendOf(david, alex) ::: If Alex hates Bob, then Alex is not friends with David.",
            "¬FriendOf(alex, x) → ¬Likes(x, jane) ::: Alex is not friends with someone who likes Jane.",
            "Hates(jane, david) ::: Jane hates David.",
            "∀x (Hates(jane, x) → Hates(x, david)) ::: Anyone who hates Jane hates David.",
            "∀x (Loves(x, jane) → ¬IsHappy(x)) ::: If someone loves Jane, then that person is not happy.",
            "IsRich(alex) → ¬IsFamous(alex) ::: If Alex is rich then Alex is not famous.",
            "Knows(bob, david) ::: Bob knows David.",
            "∃x (Knows(alex, x) ∧ IsHappy(x) ∧ CanSing(x)) ::: Alex knows someone who is happy and can sing."
        ],
        "predicates": [
            "Likes(x, y) ::: x likes y",
            "FriendOf(x, y) ::: x is a friend of y",
            "Loves(x, y) ::: x loves y",
            "Hates(x, y) ::: x hates y",
            "IsStudent(x) ::: x is a student",
            "Studies(x, y) ::: x studies y",
            "IsSmart(x) ::: x is smart",
            "IsTeacher(x) ::: x is a teacher",
            "Teaches(x, y) ::: x teaches y",
            "IsClassmateOf(x, y) ::: x is a classmate of y",
            "Attends(x, y) ::: x attends y",
            "IsHappy(x) ::: x is happy",
            "CanSing(x) ::: x can sing",
            "Knows(x, y) ::: x knows y",
            "IsFamous(x) ::: x is famous",
            "IsRich(x) ::: x is rich"
        ]
    },
    {
        "conclusion": "Therefore, either John is not happy or Mary is not a student.",
        "conclusion_FOL": "¬IsHappy(john) ∨ ¬Student(mary) ::: Therefore, either John is not happy or Mary is not a student.",
        "premises": [
            "All students like teachers.",
            "John is a student.",
            "Mary is a student.",
            "All teachers are smart.",
            "Everyone who studies likes what they study.",
            "If someone is smart, then they are happy.",
            "If someone likes something, they will study it.",
            "Everyone who is a student studies.",
            "If Mary likes John, then John is not happy.",
            "John likes Mary.",
            "If someone likes Mary, they are smart.",
            "If someone is not happy, they do not own a car.",
            "If someone is rich, they own a car.",
            "Anyone who is smart goes to school.",
            "John works at a school and John studies at a school.",
            "If John works at a school and John is successful then John is happy."
        ],
        "premises_FOL": [
            "∀x ∀y (Student(x) ∧ Teacher(y) → Likes(x, y)) ::: All students like teachers.",
            "Student(john) ::: John is a student.",
            "Student(mary) ::: Mary is a student.",
            "∀x (Teacher(x) → IsSmart(x)) ::: All teachers are smart.",
            "∀x ∀y (Studies(x, y) → Likes(x, y)) ::: Everyone who studies likes what they study.",
            "∀x (IsSmart(x) → IsHappy(x)) ::: If someone is smart, then they are happy.",
            "∀x ∀y (Likes(x, y) → Studies(x, y)) ::: If someone likes something, they will study it.",
            "∀x (Student(x) → Studies(x, y)) ::: Everyone who is a student studies.",
            "Likes(mary, john) → ¬IsHappy(john) ::: If Mary likes John, then John is not happy.",
            "Likes(john, mary) ::: John likes Mary.",
            "Likes(x, mary) → IsSmart(x) ::: If someone likes Mary, they are smart.",
            "¬IsHappy(x) → ¬HasCar(x) ::: If someone is not happy, they do not own a car.",
            "IsRich(x) → HasCar(x) ::: If someone is rich, they own a car.",
            "∀x (IsSmart(x) → GoesTo(x, school)) ::: Anyone who is smart goes to school.",
            "WorksAt(john, school) ∧ Studies(john, school) ::: John works at a school and John studies at a school.",
            "WorksAt(john, school) ∧ IsSuccessful(john) → IsHappy(john) ::: If John works at a school and John is successful then John is happy."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Teacher(x) ::: x is a teacher",
            "IsHappy(x) ::: x is happy",
            "Likes(x, y) ::: x likes y",
            "Studies(x, y) ::: x studies y",
            "Teaches(x, y) ::: x teaches y",
            "FriendOf(x, y) ::: x is a friend of y",
            "Knows(x, y) ::: x knows y",
            "IsSmart(x) ::: x is smart",
            "IsRich(x) ::: x is rich",
            "Owns(x, y) ::: x owns y",
            "GoesTo(x, y) ::: x goes to y",
            "IsTall(x) ::: x is tall",
            "IsSuccessful(x) ::: x is successful",
            "HasCar(x) ::: x has a car",
            "WorksAt(x, y) ::: x works at y"
        ]
    },
    {
        "conclusion": "If a plant receives sunlight and water, it will grow.",
        "conclusion_FOL": "∀x (Plant(x) ∧ Receives(x, Sunlight) ∧ Receives(x, Water) → Grows(x)) ::: If a plant receives sunlight and water, it will grow.",
        "premises": [
            "All plants need sunlight to grow.",
            "All plants need water to grow.",
            "A rose is a plant.",
            "If a plant is flowering, it produces oxygen.",
            "If a plant produces oxygen, it is healthy.",
            "All plants that are healthy thrive.",
            "All plants that receives sunlight produce oxygen.",
            "If a plant receives fertilizer, then it produces leaves.",
            "If a plant has leaves, the plant absorbs CO2.",
            "If a plant absorbs CO2 and receives water, the plant will grow.",
            "Plants needs fertilizer and water to thrives.",
            "A plant is flowering if it is green.",
            "All green plants have leaves.",
            "Rose receives sunlight.",
            "All Plants that are thriving are green"
        ],
        "premises_FOL": [
            "∀x (Plant(x) → Needs(x, Sunlight)) ::: All plants need sunlight to grow.",
            "∀x (Plant(x) → Needs(x, Water)) ::: All plants need water to grow.",
            "Plant(rose) ::: A rose is a plant.",
            "∀x (IsFlowering(x) → Produces(x, Oxygen)) ::: If a plant is flowering, it produces oxygen.",
            "∀x (Produces(x, Oxygen) → IsHealthy(x)) ::: If a plant produces oxygen, it is healthy.",
            "∀x (IsHealthy(x) → Thrives(x)) ::: All plants that are healthy thrive.",
            "∀x (Receives(x, Sunlight) → Produces(x, Oxygen)) ::: All plants that receives sunlight produce oxygen.",
            "∀x (Receives(x, Fertilizer) → Produces(x, Leaves)) ::: If a plant receives fertilizer, then it produces leaves.",
            "∀x (Produces(x, Leaves) → Absorbs(x, CO2)) ::: If a plant has leaves, the plant absorbs CO2.",
            "∀x (Absorbs(x, CO2) ∧ Receives(x, Water) → Grows(x)) ::: If a plant absorbs CO2 and receives water, the plant will grow.",
            "∀x (Plant(x) → Needs(x, Fertilizer) ∧ Needs(x, Water)) ::: Plants needs fertilizer and water to thrives.",
            "∀x (IsGreen(x) ∧ Plant(x) → IsFlowering(x)) ::: A plant is flowering if it is green.",
            "∀x (IsGreen(x) → HasLeaves(x)) ::: All green plants have leaves.",
            "Receives(rose, Sunlight) ::: Rose receives sunlight.",
            "∀x (Thrives(x) → IsGreen(x)) ::: All Plants that are thriving are green"
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "Receives(x, y) ::: x receives y",
            "Sunlight ::: Represents sunlight",
            "Water ::: Represents water",
            "Grows(x) ::: x grows",
            "Needs(x, y) ::: x needs y",
            "Fertilizer ::: Represents fertilizer",
            "Produces(x, y) ::: x produces y",
            "Oxygen ::: Represents oxygen",
            "IsHealthy(x) ::: x is healthy",
            "Absorbs(x, y) ::: x absorbs y",
            "CO2 ::: Represents Carbon Dioxide",
            "Thrives(x) ::: x thrives",
            "HasLeaves(x) ::: x has leaves",
            "IsGreen(x) ::: x is green",
            "IsFlowering(x) ::: x is flowering"
        ]
    },
    {
        "conclusion": "If something is a plant and receives sunlight and water, it will grow.",
        "conclusion_FOL": "∀x (Plant(x) ∧ ReceivesSunlight(x) ∧ ReceivesWater(x) → Grows(x)) ::: If something is a plant and receives sunlight and water, it will grow.",
        "premises": [
            "Every plant needs sunlight.",
            "Every plant needs water.",
            "If something is a plant and needs sunlight, then it receives sunlight.",
            "If something is a plant and needs water, then it receives water.",
            "If something grows, then it is alive.",
            "If something is a tree, then it is a plant.",
            "If something is a flower, then it is a plant.",
            "If something bears fruit, then it is a plant and grows.",
            "If something is a tree, it provides oxygen.",
            "If a plant receives sunlight and water, then it grows.",
            "Something is a plant.",
            "That thing needs sunlight.",
            "That thing needs water.",
            "If that thing bears fruit, it must be a tree.",
            "If something is a flower, then it is short.",
            "If something lives in the forest, then it is a tree.",
            "If something is a tree, then it has leaves."
        ],
        "premises_FOL": [
            "∀x (Plant(x) → NeedsSunlight(x)) ::: Every plant needs sunlight.",
            "∀x (Plant(x) → NeedsWater(x)) ::: Every plant needs water.",
            "∀x (Plant(x) ∧ NeedsSunlight(x) → ReceivesSunlight(x)) ::: If something is a plant and needs sunlight, then it receives sunlight.",
            "∀x (Plant(x) ∧ NeedsWater(x) → ReceivesWater(x)) ::: If something is a plant and needs water, then it receives water.",
            "∀x (Grows(x) → IsAlive(x)) ::: If something grows, then it is alive.",
            "∀x (IsTree(x) → Plant(x)) ::: If something is a tree, then it is a plant.",
            "∀x (IsFlower(x) → Plant(x)) ::: If something is a flower, then it is a plant.",
            "∀x (BearsFruit(x) → Plant(x) ∧ Grows(x)) ::: If something bears fruit, then it is a plant and grows.",
            "∀x (IsTree(x) → ProvidesOxygen(x)) ::: If something is a tree, it provides oxygen.",
            "∀x (Plant(x) ∧ ReceivesSunlight(x) ∧ ReceivesWater(x) → Grows(x)) ::: If a plant receives sunlight and water, then it grows.",
            "∃x Plant(x) ::: Something is a plant.",
            "NeedsSunlight(that) ::: That thing needs sunlight.",
            "NeedsWater(that) ::: That thing needs water.",
            "∀x (BearsFruit(x) → IsTree(x)) ::: If that thing bears fruit, it must be a tree.",
            "∀x (IsFlower(x) → IsShort(x)) ::: If something is a flower, then it is short.",
            "∀x (LivesInForest(x) → IsTree(x)) ::: If something lives in the forest, then it is a tree.",
            "∀x (IsTree(x) → HasLeaves(x)) ::: If something is a tree, then it has leaves."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "ReceivesSunlight(x) ::: x receives sunlight",
            "ReceivesWater(x) ::: x receives water",
            "Grows(x) ::: x grows",
            "IsGreen(x) ::: x is green",
            "HasLeaves(x) ::: x has leaves",
            "NeedsSunlight(x) ::: x needs sunlight",
            "NeedsWater(x) ::: x needs water",
            "IsAlive(x) ::: x is alive",
            "BearsFruit(x) ::: x bears fruit",
            "ProvidesOxygen(x) ::: x provides oxygen",
            "IsTall(x) ::: x is tall",
            "IsShort(x) ::: x is short",
            "LivesInForest(x) ::: x lives in the forest",
            "IsTree(x) ::: x is a tree",
            "IsFlower(x) ::: x is a flower"
        ]
    },
    {
        "conclusion": "Some people who like cats do not like dogs.",
        "conclusion_FOL": "∃x (LikesCats(x) ∧ ¬LikesDogs(x)) ::: There exists someone who likes cats and does not like dogs.",
        "premises": [
            "All people who own a cat like cats.",
            "All people who own a dog like dogs.",
            "Some people are allergic to cats.",
            "All people who are allergic to cats do not like cats.",
            "All pet owners like dogs.",
            "All friendly people like cats.",
            "No mean people like dogs.",
            "Some people play with cats.",
            "All people who play with cats are happy.",
            "Some people hate cats.",
            "All people who hate cats do not like cats.",
            "All people who are happy have friends.",
            "Some people do not have friends.",
            "Some people like dogs and do not like cats.",
            "Everyone who is generous is a neighbor.",
            "All people who own a cat are generous.",
            "No one who is a neighbor owns a dog."
        ],
        "premises_FOL": [
            "∀x (OwnsCat(x) → LikesCats(x)) ::: All people who own a cat like cats.",
            "∀x (OwnsDog(x) → LikesDogs(x)) ::: All people who own a dog like dogs.",
            "∃x AllergicToCats(x) ::: Some people are allergic to cats.",
            "∀x (AllergicToCats(x) → ¬LikesCats(x)) ::: All people who are allergic to cats do not like cats.",
            "∀x (IsPetOwner(x) → LikesDogs(x)) ::: All pet owners like dogs.",
            "∀x (IsFriendly(x) → LikesCats(x)) ::: All friendly people like cats.",
            "∀x (IsMean(x) → ¬LikesDogs(x)) ::: No mean people like dogs.",
            "∃x PlaysWithCats(x) ::: Some people play with cats.",
            "∀x (PlaysWithCats(x) → IsHappy(x)) ::: All people who play with cats are happy.",
            "∃x HatesCats(x) ::: Some people hate cats.",
            "∀x (HatesCats(x) → ¬LikesCats(x)) ::: All people who hate cats do not like cats.",
            "∀x (IsHappy(x) → HasFriends(x)) ::: All people who are happy have friends.",
            "∃x ¬HasFriends(x) ::: Some people do not have friends.",
            "∃x (LikesDogs(x) ∧ ¬LikesCats(x)) ::: Some people like dogs and do not like cats.",
            "∀x ∀y (IsGenerous(x) → IsNeighborOf(x, y)) ::: Everyone who is generous is a neighbor.",
            "∀x (OwnsCat(x) → IsGenerous(x)) ::: All people who own a cat are generous.",
            "∀x ∀y (IsNeighborOf(x, y) → ¬OwnsDog(x)) ::: No one who is a neighbor owns a dog."
        ],
        "predicates": [
            "LikesCats(x) ::: x likes cats",
            "LikesDogs(x) ::: x likes dogs",
            "OwnsCat(x) ::: x owns a cat",
            "OwnsDog(x) ::: x owns a dog",
            "AllergicToCats(x) ::: x is allergic to cats",
            "AllergicToDogs(x) ::: x is allergic to dogs",
            "IsPetOwner(x) ::: x is a pet owner",
            "IsFriendly(x) ::: x is friendly",
            "IsMean(x) ::: x is mean",
            "PlaysWithCats(x) ::: x plays with cats",
            "PlaysWithDogs(x) ::: x plays with dogs",
            "IsHappy(x) ::: x is happy",
            "HatesCats(x) ::: x hates cats",
            "HatesDogs(x) ::: x hates dogs",
            "HasFriends(x) ::: x has friends",
            "IsNeighborOf(x, y) ::: x is a neighbor of y",
            "IsGenerous(x) ::: x is generous"
        ]
    },
    {
        "conclusion": "If something is a disease, then it causes illness or death.",
        "conclusion_FOL": "∀x (Disease(x) → (CausesIllness(x) ∨ CausesDeath(x))) ::: If something is a disease, then it causes illness or death.",
        "premises": [
            "All viral diseases are spreadable.",
            "All bacterial diseases are treatable or fatal.",
            "If something is a disease and spreadable, then it's in a human.",
            "If a disease is in a human, then it causes illness or death.",
            "All diseases are treatable or causes symptoms.",
            "If a disease is fatal, it is severe.",
            "If a disease is viral, then it affects a specific organ.",
            "If a disease is bacterial and not curable, then it is fatal.",
            "Some diseases are viral and not bacterial.",
            "If a disease is viral, then it causes illness or death.",
            "If a disease causes death, it is severe.",
            "If a disease is chronic, then it has symptoms.",
            "Every disease is a disease.",
            "If something is a disease and curable, then it's not chronic.",
            "Some diseases affect humans and organs.",
            "If a disease causes illness, it is treatable."
        ],
        "premises_FOL": [
            "∀x (IsViral(x) → Spreadable(x)) ::: All viral diseases are spreadable.",
            "∀x (IsBacterial(x) → (Treatable(x) ∨ Fatal(x))) ::: All bacterial diseases are treatable or fatal.",
            "∀x (Disease(x) ∧ Spreadable(x) → InHuman(x)) ::: If something is a disease and spreadable, then it's in a human.",
            "∀x (InHuman(x) → (CausesIllness(x) ∨ CausesDeath(x))) ::: If a disease is in a human, then it causes illness or death.",
            "∀x (Disease(x) → (Treatable(x) ∨ CausesSymptoms(x))) ::: All diseases are treatable or causes symptoms.",
            "∀x (Fatal(x) → Severe(x)) ::: If a disease is fatal, it is severe.",
            "∀x (IsViral(x) → AffectsOrgan(x, some_organ)) ::: If a disease is viral, then it affects a specific organ.",
            "∀x (IsBacterial(x) ∧ ¬Curable(x) → Fatal(x)) ::: If a disease is bacterial and not curable, then it is fatal.",
            "∃x (IsViral(x) ∧ ¬IsBacterial(x)) ::: Some diseases are viral and not bacterial.",
            "∀x (IsViral(x) → (CausesIllness(x) ∨ CausesDeath(x))) ::: If a disease is viral, then it causes illness or death.",
            "∀x (CausesDeath(x) → Severe(x)) ::: If a disease causes death, it is severe.",
            "∀x (IsChronic(x) → HasSymptoms(x)) ::: If a disease is chronic, then it has symptoms.",
            "∀x (Disease(x) → Disease(x)) ::: Every disease is a disease.",
            "∀x (Disease(x) ∧ Curable(x) → ¬IsChronic(x)) ::: If something is a disease and curable, then it's not chronic.",
            "∃x ∃y (Disease(x) ∧ Affects(x, y) ∧ InHuman(x)) ::: Some diseases affect humans and organs.",
            "∀x (CausesIllness(x) → Treatable(x)) ::: If a disease causes illness, it is treatable."
        ],
        "predicates": [
            "Disease(x) ::: x is a disease",
            "Treatable(x) ::: x is treatable",
            "CausesIllness(x) ::: x causes illness",
            "CausesDeath(x) ::: x causes death",
            "IsViral(x) ::: x is viral",
            "IsBacterial(x) ::: x is bacterial",
            "Affects(x, y) ::: x affects y",
            "InHuman(x) ::: x is in a human",
            "Curable(x) ::: x is curable",
            "Severe(x) ::: x is severe",
            "Spreadable(x) ::: x is spreadable",
            "CausesSymptoms(x, y) ::: x causes symptoms y",
            "HasSymptoms(x) ::: x has symptoms",
            "AffectsOrgan(x, y) ::: x affects organ y",
            "Fatal(x) ::: x is fatal",
            "IsChronic(x) ::: x is chronic"
        ]
    },
    {
        "conclusion": "If an individual is a member of the economics club, then they are also a student.",
        "conclusion_FOL": "∀x (MemberOfEconomicsClub(x) → Student(x)) ::: If an individual is a member of the economics club, then they are also a student.",
        "premises": [
            "All members of the economics club attend economics meetings.",
            "All who attend economics meetings are students or professors.",
            "No professor is a member of the debate club.",
            "All professors give lectures.",
            "Anyone who gives lectures teaches economics.",
            "Everyone who teaches economics is a professor or a TA.",
            "All TAs advise students.",
            "All who advise students are students.",
            "Anyone who studies economics is interested in finance.",
            "All members of the economics club are interested in finance.",
            "All members of the debate club enjoy debate.",
            "Professors and TAs have office hours.",
            "No professor is a student.",
            "All who teaches economics has published a paper.",
            "Someone studies economics and advises student.",
            "Graduate students study economics.",
            "No TA is a member of the economics club."
        ],
        "premises_FOL": [
            "∀x (MemberOfEconomicsClub(x) → AttendsEconomicsMeetings(x)) ::: All members of the economics club attend economics meetings.",
            "∀x (AttendsEconomicsMeetings(x) → (Student(x) ∨ Professor(x))) ::: All who attend economics meetings are students or professors.",
            "∀x (Professor(x) → ¬MemberOfDebateClub(x)) ::: No professor is a member of the debate club.",
            "∀x (Professor(x) → GivesLectures(x)) ::: All professors give lectures.",
            "∀x (GivesLectures(x) → TeachesEconomics(x)) ::: Anyone who gives lectures teaches economics.",
            "∀x (TeachesEconomics(x) → (Professor(x) ∨ TA(x))) ::: Everyone who teaches economics is a professor or a TA.",
            "∀x (TA(x) → AdvisesStudents(x, some_student)) ::: All TAs advise students.",
            "∀x ∀y (AdvisesStudents(x, y) → Student(y)) ::: All who advise students are students.",
            "∀x (StudiesEconomics(x) → IsInterestedInFinance(x)) ::: Anyone who studies economics is interested in finance.",
            "∀x (MemberOfEconomicsClub(x) → IsInterestedInFinance(x)) ::: All members of the economics club are interested in finance.",
            "∀x (MemberOfDebateClub(x) → EnjoysDebate(x)) ::: All members of the debate club enjoy debate.",
            "∀x (Professor(x) ∨ TA(x) → HasOfficeHours(x)) ::: Professors and TAs have office hours.",
            "∀x (Professor(x) → ¬Student(x)) ::: No professor is a student.",
            "∀x (TeachesEconomics(x) → HasPublishedPaper(x)) ::: All who teaches economics has published a paper.",
            "∃x ∃y (StudiesEconomics(x) ∧ AdvisesStudents(x, y)) ::: Someone studies economics and advises student.",
            "∀x (GradStudent(x) → StudiesEconomics(x)) ::: Graduate students study economics.",
            "∀x (TA(x) → ¬MemberOfEconomicsClub(x)) ::: No TA is a member of the economics club."
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Professor(x) ::: x is a professor",
            "TA(x) ::: x is a teaching assistant",
            "MemberOfEconomicsClub(x) ::: x is a member of the economics club",
            "MemberOfDebateClub(x) ::: x is a member of the debate club",
            "AttendsEconomicsMeetings(x) ::: x attends economics meetings",
            "GivesLectures(x) ::: x gives lectures",
            "AdvisesStudents(x, y) ::: x advises student y",
            "StudiesEconomics(x) ::: x studies economics",
            "HasOfficeHours(x) ::: x has office hours",
            "EnjoysDebate(x) ::: x enjoys debate",
            "IsInterestedInFinance(x) ::: x is interested in finance",
            "HasPublishedPaper(x) ::: x has published a paper",
            "TeachesEconomics(x) ::: x teaches economics",
            "HasAdvised(x, y) ::: x has advised y",
            "IsResearcher(x) ::: x is a researcher",
            "GradStudent(x) ::: x is a graduate student"
        ]
    },
    {
        "conclusion": "If someone is a software engineer, then they know how to code and they have a computer.",
        "conclusion_FOL": "∀x (SoftwareEngineer(x) → (KnowsHowToCode(x) ∧ HasComputer(x))) ::: If someone is a software engineer, then they know how to code and they have a computer.",
        "premises": [
            "All software engineers work for tech companies.",
            "All software engineers know how to code.",
            "All software engineers have a computer.",
            "Anyone who works for a tech company uses programming languages.",
            "Anyone who attends a coding bootcamp knows how to code.",
            "Anyone with a degree in computer science knows how to code.",
            "All software engineers design websites.",
            "Anyone who designs websites knows algorithms.",
            "All software engineers write documentation.",
            "All software engineers collaborate on projects.",
            "All software engineers are productive.",
            "Anyone who uses Linux knows how to code and has a computer.",
            "Anyone who knows algorithms solves problems.",
            "Anyone who is certified knows how to code.",
            "All who write code knows how to code and has a computer.",
            "All software engineers test software.",
            "Anyone who reads documentation knows how to code.",
            "Software engineers use Linux."
        ],
        "premises_FOL": [
            "∀x (SoftwareEngineer(x) → WorksForTechCompany(x)) ::: All software engineers work for tech companies.",
            "∀x (SoftwareEngineer(x) → KnowsHowToCode(x)) ::: All software engineers know how to code.",
            "∀x (SoftwareEngineer(x) → HasComputer(x)) ::: All software engineers have a computer.",
            "∀x (WorksForTechCompany(x) → UsesProgrammingLanguages(x, some_language)) ::: Anyone who works for a tech company uses programming languages.",
            "∀x (AttendsCodingBootcamp(x) → KnowsHowToCode(x)) ::: Anyone who attends a coding bootcamp knows how to code.",
            "∀x (HasDegreeInCS(x) → KnowsHowToCode(x)) ::: Anyone with a degree in computer science knows how to code.",
            "∀x (SoftwareEngineer(x) → DesignsWebsites(x)) ::: All software engineers design websites.",
            "∀x (DesignsWebsites(x) → KnowsAlgorithms(x)) ::: Anyone who designs websites knows algorithms.",
            "∀x (SoftwareEngineer(x) → WritesDocumentation(x)) ::: All software engineers write documentation.",
            "∀x (SoftwareEngineer(x) → CollaboratesOnProjects(x)) ::: All software engineers collaborate on projects.",
            "∀x (SoftwareEngineer(x) → IsProductive(x)) ::: All software engineers are productive.",
            "∀x (UsesLinux(x) → (KnowsHowToCode(x) ∧ HasComputer(x))) ::: Anyone who uses Linux knows how to code and has a computer.",
            "∀x (KnowsAlgorithms(x) → SolvesProblems(x)) ::: Anyone who knows algorithms solves problems.",
            "∀x ∀y (IsCertified(x, y) → KnowsHowToCode(x)) ::: Anyone who is certified knows how to code.",
            "∀x (WritesCode(x) → (KnowsHowToCode(x) ∧ HasComputer(x))) ::: All who write code knows how to code and has a computer.",
            "∀x (SoftwareEngineer(x) → TestsSoftware(x)) ::: All software engineers test software.",
            "∀x (ReadsDocumentation(x) → KnowsHowToCode(x)) ::: Anyone who reads documentation knows how to code.",
            "∀x (SoftwareEngineer(x) → UsesLinux(x)) ::: Software engineers use Linux."
        ],
        "predicates": [
            "SoftwareEngineer(x) ::: x is a software engineer",
            "KnowsHowToCode(x) ::: x knows how to code",
            "HasComputer(x) ::: x has a computer",
            "WorksForTechCompany(x) ::: x works for a tech company",
            "UsesProgrammingLanguages(x, y) ::: x uses programming language y",
            "AttendsCodingBootcamp(x) ::: x attends a coding bootcamp",
            "HasDegreeInCS(x) ::: x has a degree in computer science",
            "DesignsWebsites(x) ::: x designs websites",
            "KnowsAlgorithms(x) ::: x knows algorithms",
            "WritesDocumentation(x) ::: x writes documentation",
            "CollaboratesOnProjects(x) ::: x collaborates on projects",
            "IsProductive(x) ::: x is productive",
            "UsesLinux(x) ::: x uses linux",
            "SolvesProblems(x) ::: x solves problems",
            "IsCertified(x, y) ::: x is certified in y",
            "WritesCode(x) ::: x writes code",
            "TestsSoftware(x) ::: x tests software",
            "ReadsDocumentation(x) ::: x reads documentation"
        ]
    },
    {
        "conclusion": "If someone is a scientist who studies biology and physics, then they are either a biologist or a physicist.",
        "conclusion_FOL": "∀x (Scientist(x) ∧ StudiesBiology(x) ∧ StudiesPhysics(x) → (Biologist(x) ∨ Physicist(x))) ::: If someone is a scientist who studies biology and physics, then they are either a biologist or a physicist.",
        "premises": [
            "All scientists study at least one of biology, physics, or chemistry.",
            "All biologists study biology.",
            "All physicists study physics.",
            "All chemists study chemistry.",
            "If someone studies biology and physics, then they are a scientist.",
            "Anyone who works at a university publishes papers or conducts experiments.",
            "All biologists specialize in genetics or studies biochemistry.",
            "Anyone who studies biology uses a microscope or studies ecology.",
            "All physicists know thermodynamics and quantum mechanics.",
            "Scientists either specialize in genetics or study biochemistry.",
            "If someone studies astronomy, then they're not a biologist or a physicist.",
            "If someone studies physics and biology, then they collaborate.",
            "Anyone who studies physics and chemistry writes grants.",
            "All who write grants is a scientist.",
            "All those who collaborate with biologist are a scientist.",
            "Anyone who conducts experiment are scientist.",
            "All scientists works at a university and publish papers.",
            "All chemist studies chemistry and biochemistry.",
            "All physicists also study astrophysics."
        ],
        "premises_FOL": [
            "∀x (Scientist(x) → (StudiesBiology(x) ∨ StudiesPhysics(x) ∨ StudiesChemistry(x))) ::: All scientists study at least one of biology, physics, or chemistry.",
            "∀x (Biologist(x) → StudiesBiology(x)) ::: All biologists study biology.",
            "∀x (Physicist(x) → StudiesPhysics(x)) ::: All physicists study physics.",
            "∀x (Chemist(x) → StudiesChemistry(x)) ::: All chemists study chemistry.",
            "∀x ((StudiesBiology(x) ∧ StudiesPhysics(x)) → Scientist(x)) ::: If someone studies biology and physics, then they are a scientist.",
            "∀x (WorksAtUniversity(x) → (PublishesPapers(x) ∨ ConductsExperiments(x))) ::: Anyone who works at a university publishes papers or conducts experiments.",
            "∀x (Biologist(x) → (SpecializesInGenetics(x) ∨ StudiesBiochemistry(x))) ::: All biologists specialize in genetics or studies biochemistry.",
            "∀x (StudiesBiology(x) → (UsesMicroscope(x) ∨ StudiesEcology(x))) ::: Anyone who studies biology uses a microscope or studies ecology.",
            "∀x (Physicist(x) → (KnowsThermodynamics(x) ∧ KnowsQuantumMechanics(x))) ::: All physicists know thermodynamics and quantum mechanics.",
            "∀x (Scientist(x) → (SpecializesInGenetics(x) ∨ StudiesBiochemistry(x))) ::: Scientists either specialize in genetics or study biochemistry.",
            "∀x (StudiesAstronomy(x) → (¬Biologist(x) ∧ ¬Physicist(x))) ::: If someone studies astronomy, then they're not a biologist or a physicist.",
            "∀x ∀y ((StudiesPhysics(x) ∧ StudiesBiology(x)) → CollaboratesWith(x, y)) ::: If someone studies physics and biology, then they collaborate.",
            "∀x (StudiesPhysics(x) ∧ StudiesChemistry(x) → WritesGrants(x)) ::: Anyone who studies physics and chemistry writes grants.",
            "∀x (WritesGrants(x) → Scientist(x)) ::: All who write grants is a scientist.",
            "∀x ∀y (CollaboratesWith(x, y) → Scientist(x)) ::: All those who collaborate with biologist are a scientist.",
            "∀x (ConductsExperiments(x) → Scientist(x)) ::: Anyone who conducts experiment are scientist.",
            "∀x (Scientist(x) → (WorksAtUniversity(x) ∧ PublishesPapers(x))) ::: All scientists works at a university and publish papers.",
            "∀x (Chemist(x) → (StudiesChemistry(x) ∧ StudiesBiochemistry(x))) ::: All chemist studies chemistry and biochemistry.",
            "∀x (Physicist(x) → StudiesAstronomy(x)) ::: All physicists also study astrophysics."
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "StudiesBiology(x) ::: x studies biology",
            "StudiesPhysics(x) ::: x studies physics",
            "StudiesChemistry(x) ::: x studies chemistry",
            "Biologist(x) ::: x is a biologist",
            "Physicist(x) ::: x is a physicist",
            "Chemist(x) ::: x is a chemist",
            "WorksAtUniversity(x) ::: x works at a university",
            "PublishesPapers(x) ::: x publishes papers",
            "ConductsExperiments(x) ::: x conducts experiments",
            "SpecializesInGenetics(x) ::: x specializes in genetics",
            "UsesMicroscope(x) ::: x uses a microscope",
            "StudiesAstronomy(x) ::: x studies astronomy",
            "StudiesEcology(x) ::: x studies ecology",
            "KnowsThermodynamics(x) ::: x knows thermodynamics",
            "KnowsQuantumMechanics(x) ::: x knows quantum mechanics",
            "StudiesBiochemistry(x) ::: x studies biochemistry",
            "CollaboratesWith(x, y) ::: x collaborates with y",
            "WritesGrants(x) ::: x writes grants"
        ]
    },
    {
        "conclusion": "If an organism is a plant and is in sunlight, then it performs photosynthesis and grows.",
        "conclusion_FOL": "∀x (Plant(x) ∧ InSunlight(x) → PerformsPhotosynthesis(x) ∧ Grows(x)) ::: If an organism is a plant and is in sunlight, then it performs photosynthesis and grows.",
        "premises": [
            "All plants are organisms.",
            "All organisms need water.",
            "If something is a plant, it needs sunlight.",
            "Anything that needs sunlight, if it is watered, will perform photosynthesis.",
            "Anything that performs photosynthesis grows.",
            "If something is a plant and is watered, it will grow.",
            "All organisms need nutrients.",
            "If something is healthy, it receives nutrients.",
            "Anything that receives nutrients is alive.",
            "All plants are watered.",
            "Animals eat plants.",
            "All herbivores eat plants.",
            "All plants are in sunlight.",
            "Some organisms are plants.",
            "Some animals are herbivores.",
            "Plants perform photosynthesis."
        ],
        "premises_FOL": [
            "∀x (Plant(x) → Organism(x)) ::: All plants are organisms.",
            "∀x (Organism(x) → NeedsWater(x)) ::: All organisms need water.",
            "∀x (Plant(x) → InSunlight(x)) ::: If something is a plant, it needs sunlight.",
            "∀x (InSunlight(x) ∧ Watered(x) → PerformsPhotosynthesis(x)) ::: Anything that needs sunlight, if it is watered, will perform photosynthesis.",
            "∀x (PerformsPhotosynthesis(x) → Grows(x)) ::: Anything that performs photosynthesis grows.",
            "∀x (Plant(x) ∧ Watered(x) → Grows(x)) ::: If something is a plant and is watered, it will grow.",
            "∀x (Organism(x) → NeedsNutrients(x)) ::: All organisms need nutrients.",
            "∀x (Healthy(x) → ReceivesNutrients(x)) ::: If something is healthy, it receives nutrients.",
            "∀x (ReceivesNutrients(x) → Alive(x)) ::: Anything that receives nutrients is alive.",
            "∀x (Plant(x) → Watered(x)) ::: All plants are watered.",
            "∀x ∃y (Animal(x) → Eats(x, y) ∧ Plant(y)) ::: Animals eat plants.",
            "∀x (Herbivore(x) → EatsPlant(x)) ::: All herbivores eat plants.",
            "∀x (Plant(x) → InSunlight(x)) ::: All plants are in sunlight.",
            "∃x (Organism(x) ∧ Plant(x)) ::: Some organisms are plants.",
            "∃x (Animal(x) ∧ Herbivore(x)) ::: Some animals are herbivores.",
            "∀x (Plant(x) → PerformsPhotosynthesis(x)) ::: Plants perform photosynthesis."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "InSunlight(x) ::: x is in sunlight",
            "PerformsPhotosynthesis(x) ::: x performs photosynthesis",
            "Grows(x) ::: x grows",
            "Organism(x) ::: x is an organism",
            "NeedsWater(x) ::: x needs water",
            "Watered(x) ::: x is watered",
            "Alive(x) ::: x is alive",
            "Healthy(x) ::: x is healthy",
            "NeedsNutrients(x) ::: x needs nutrients",
            "ReceivesNutrients(x) ::: x receives nutrients",
            "Animal(x) ::: x is an animal",
            "Eats(x, y) ::: x eats y",
            "Herbivore(x) ::: x is a herbivore",
            "EatsPlant(x) ::: x eats plant",
            "Sunlight(y) ::: y is sunlight"
        ]
    },
    {
        "conclusion": "If an individual is a member of a social group and posts regularly, they are likely to gain more followers and be more influential.",
        "conclusion_FOL": "∀x (MemberOf(x, g) ∧ PostsRegularly(x) → (HasFollowers(x) ∧ Influential(x))) ::: If an individual is a member of a social group and posts regularly, they are likely to gain more followers and be more influential.",
        "premises": [
            "All members of a social group engage with content.",
            "Anyone who engages with popular content creates more content.",
            "Anyone who creates content also shares content.",
            "Anyone who shares content comments on it.",
            "Everyone who comments on content likes the content.",
            "If content is popular, it receives likes.",
            "If content is trending, it is also popular.",
            "Anyone who is active posts regularly.",
            "Anyone who posts regularly has followers.",
            "Anyone who has followers is visible.",
            "If someone is visible and is part of a social group they are influential.",
            "Everyone is a member of a social group.",
            "There is some content.",
            "Some content is popular.",
            "Some content is trending.",
            "Some people are active.",
            "All active people engage with content."
        ],
        "premises_FOL": [
            "∀x ∀y (MemberOf(x, y) → Engages(x, y)) ::: All members of a social group engage with content.",
            "∀x ∀y (Engages(x, y) ∧ Popular(y) → CreatesContent(x, y)) ::: Anyone who engages with popular content creates more content.",
            "∀x ∀y (CreatesContent(x, y) → SharesContent(x, y)) ::: Anyone who creates content also shares content.",
            "∀x ∀y (SharesContent(x, y) → Comments(x, y)) ::: Anyone who shares content comments on it.",
            "∀x ∀y (Comments(x, y) → Likes(x, y)) ::: Everyone who comments on content likes the content.",
            "∀y (Popular(y) → ReceivesLikes(y)) ::: If content is popular, it receives likes.",
            "∀y (Trending(y) → Popular(y)) ::: If content is trending, it is also popular.",
            "∀x (Active(x) → PostsRegularly(x)) ::: Anyone who is active posts regularly.",
            "∀x (PostsRegularly(x) → HasFollowers(x)) ::: Anyone who posts regularly has followers.",
            "∀x (HasFollowers(x) → Visible(x)) ::: Anyone who has followers is visible.",
            "∀x ∀y (Visible(x) ∧ MemberOf(x, y) → Influential(x)) ::: If someone is visible and is part of a social group they are influential.",
            "∀x ∃y (MemberOf(x, y) ∧ SocialGroup(y)) ::: Everyone is a member of a social group.",
            "∃y (Content(y)) ::: There is some content.",
            "∃y (Popular(y)) ::: Some content is popular.",
            "∃y (Trending(y)) ::: Some content is trending.",
            "∃x (Active(x)) ::: Some people are active.",
            "∀x ∀y (Active(x) → Engages(x, y)) ::: All active people engage with content."
        ],
        "predicates": [
            "MemberOf(x, y) ::: x is a member of group y",
            "PostsRegularly(x) ::: x posts regularly",
            "HasFollowers(x) ::: x has followers",
            "Influential(x) ::: x is influential",
            "SocialGroup(y) ::: y is a social group",
            "Engages(x, y) ::: x engages with content y",
            "Content(y) ::: y is content",
            "CreatesContent(x, y) ::: x creates content y",
            "SharesContent(x, y) ::: x shares content y",
            "Comments(x, y) ::: x comments on content y",
            "Likes(x, y) ::: x likes content y",
            "Popular(y) ::: y is popular",
            "Trending(y) ::: y is trending",
            "Active(x) ::: x is active",
            "ReceivesLikes(y) ::: content y receives likes",
            "Visible(x) ::: x is visible",
            "FriendsWith(x, y) ::: x is friends with y"
        ]
    },
    {
        "conclusion": "If all birds can fly, Tweety is a bird, and all things that fly are in the sky, then Tweety is in the sky.",
        "conclusion_FOL": "InSky(tweety) ::: Tweety is in the sky.",
        "premises": [
            "All birds can fly.",
            "Tweety is a bird.",
            "All things that fly are in the sky.",
            "All birds eat worms.",
            "All worms are green.",
            "All things that are big are cats.",
            "All cats chase mice.",
            "Mice hide in trees.",
            "All trees are yellow.",
            "All birds have feathers.",
            "All things with feathers lay eggs.",
            "Tweety has feathers.",
            "If something is a bird, it lays eggs.",
            "If something lays eggs, then it eats worms.",
            "If something is in the sky and sees a cat, then it can chase."
        ],
        "premises_FOL": [
            "∀x (Bird(x) → CanFly(x)) ::: All birds can fly.",
            "Bird(tweety) ::: Tweety is a bird.",
            "∀x (CanFly(x) → InSky(x)) ::: All things that fly are in the sky.",
            "∀x ∃y (Bird(x) → Eats(x, y) ∧ Worm(y)) ::: All birds eat worms.",
            "∀x (Worm(x) → Green(x)) ::: All worms are green.",
            "∀x (Big(x) → Cat(x)) ::: All things that are big are cats.",
            "∀x ∃y (Cat(x) → Chases(x, y) ∧ Mouse(y)) ::: All cats chase mice.",
            "∀x ∃y (Mouse(x) → Hides(x, y) ∧ Tree(y)) ::: Mice hide in trees.",
            "∀x (Tree(x) → Yellow(x)) ::: All trees are yellow.",
            "∀x (Bird(x) → HasFeathers(x)) ::: All birds have feathers.",
            "∀x (HasFeathers(x) → LaysEggs(x)) ::: All things with feathers lay eggs.",
            "HasFeathers(tweety) ::: Tweety has feathers.",
            "∀x (Bird(x) → LaysEggs(x)) ::: If something is a bird, it lays eggs.",
            "∀x (LaysEggs(x) → Eats(x, y) ∧ Worm(y)) ::: If something lays eggs, then it eats worms.",
            "∀x ∀y (InSky(x) ∧ Sees(x, y) ∧ Cat(y) → Chases(x, y)) ::: If something is in the sky and sees a cat, then it can chase."
        ],
        "predicates": [
            "Bird(x) ::: x is a bird",
            "CanFly(x) ::: x can fly",
            "InSky(x) ::: x is in the sky",
            "Eats(x, y) ::: x eats y",
            "Worm(x) ::: x is a worm",
            "Green(x) ::: x is green",
            "Big(x) ::: x is big",
            "Sees(x, y) ::: x sees y",
            "Cat(x) ::: x is a cat",
            "Chases(x, y) ::: x chases y",
            "Mouse(x) ::: x is a mouse",
            "Hides(x, y) ::: x hides in y",
            "Tree(x) ::: x is a tree",
            "Yellow(x) ::: x is yellow",
            "HasFeathers(x) ::: x has feathers",
            "LaysEggs(x) ::: x lays eggs"
        ]
    },
    {
        "conclusion": "Therefore, if anyone studies philosophy, they will either be knowledgeable or critical, but not both.",
        "conclusion_FOL": "∀x (Studies(x, philosophy) → (Knowledgeable(x) ⊕ Critical(x))) ::: For all x, if x studies philosophy, then x is either knowledgeable or critical, but not both.",
        "premises": [
            "If someone studies philosophy, they read philosophical texts.",
            "If someone reads philosophical texts, they either understand them or they are critical of them.",
            "If someone is knowledgeable and reads philosophical texts, then they attend lectures.",
            "Someone who writes essays is knowledgeable.",
            "If someone loves debate and is intelligent, they are critical.",
            "Anyone who studies philosophy presents arguments.",
            "Anyone who studies philosophy values logic.",
            "Anyone who is open-minded and curious is knowledgeable.",
            "Anyone who is skeptical and passionate is critical.",
            "If someone is open-minded, they will be knowledgeable if they study philosophy.",
            "If someone values logic, they will be critical if they study philosophy.",
            "If someone attends lectures and understands philosophy, then they are knowledgeable.",
            "If someone disagrees with many philosophical texts, they are critical."
        ],
        "premises_FOL": [
            "∀x (Studies(x, philosophy) → Reads(x, philosophicalTexts)) ::: For all x, if x studies philosophy, then x reads philosophical texts.",
            "∀x (Reads(x, philosophicalTexts) → (Understands(x, philosophicalTexts) ∨ Critical(x))) ::: For all x, if x reads philosophical texts, then they either understand them or are critical of them.",
            "∀x (Knowledgeable(x) ∧ Reads(x, philosophicalTexts) → AttendsLectures(x)) ::: For all x, if x is knowledgeable and reads philosophical texts, then they attend lectures.",
            "∀x (WritesEssays(x) → Knowledgeable(x)) ::: For all x, if x writes essays, then they are knowledgeable.",
            "∀x (LovesDebate(x) ∧ IsIntelligent(x) → Critical(x)) ::: For all x, if x loves debate and is intelligent, then they are critical.",
            "∀x (Studies(x, philosophy) → PresentsArguments(x)) ::: For all x, if x studies philosophy, then they present arguments.",
            "∀x (Studies(x, philosophy) → ValuesLogic(x)) ::: For all x, if x studies philosophy, then they value logic.",
            "∀x (IsOpenMinded(x) ∧ IsCurious(x) → Knowledgeable(x)) ::: For all x, if x is open-minded and curious, then they are knowledgeable.",
            "∀x (IsSkeptical(x) ∧ IsPassionate(x) → Critical(x)) ::: For all x, if x is skeptical and passionate, then they are critical.",
            "∀x (IsOpenMinded(x) ∧ Studies(x, philosophy) → Knowledgeable(x)) ::: For all x, if x is open-minded, then they are knowledgeable if they study philosophy.",
            "∀x (ValuesLogic(x) ∧ Studies(x, philosophy) → Critical(x)) ::: For all x, if x values logic, then they are critical if they study philosophy.",
            "∀x (AttendsLectures(x) ∧ Understands(x, philosophy) → Knowledgeable(x)) ::: For all x, if x attends lectures and understands philosophy, then they are knowledgeable.",
            "∀x (DisagreesWith(x, philosophicalTexts) → Critical(x)) ::: For all x, if x disagrees with many philosophical texts, then they are critical."
        ],
        "predicates": [
            "Studies(x, y) ::: x studies y",
            "Knowledgeable(x) ::: x is knowledgeable",
            "Critical(x) ::: x is critical",
            "Reads(x, y) ::: x reads y",
            "Understands(x, y) ::: x understands y",
            "WritesEssays(x) ::: x writes essays",
            "AttendsLectures(x) ::: x attends lectures",
            "IsIntelligent(x) ::: x is intelligent",
            "LovesDebate(x) ::: x loves debate",
            "DisagreesWith(x, y) ::: x disagrees with y",
            "PresentsArguments(x) ::: x presents arguments",
            "IsPassionate(x) ::: x is passionate",
            "IsSkeptical(x) ::: x is skeptical",
            "ValuesLogic(x) ::: x values logic",
            "IsOpenMinded(x) ::: x is open minded",
            "IsCurious(x) ::: x is curious"
        ]
    },
    {
        "conclusion": "If a plant needs sunlight and water, and it is not a desert plant, then it will grow.",
        "conclusion_FOL": "∀x ((NeedsSunlight(x) ∧ NeedsWater(x) ∧ ¬DesertPlant(x)) → Grows(x)) ::: If a plant needs sunlight and water, and it is not a desert plant, then it will grow.",
        "premises": [
            "Every plant needs sunlight.",
            "Every plant needs water.",
            "If a plant is not a desert plant, it will grow.",
            "Some plants are located in a forest.",
            "If something contains water, it will grow.",
            "If something is edible, it provides food.",
            "If something is pollinated then it produces seeds.",
            "If a plant has a flower, then it will grow.",
            "If a plant produces fruit then it's a tree.",
            "If an animal eats a plant then it is an herbivore.",
            "If a plant provides food for an animal, then it is edible.",
            "A plant has seeds.",
            "If a plant needs sunlight and water, and it is not a desert plant, then it will grow.",
            "If a plant has seeds then it has a flower.",
            "If something is a tree, it produces fruit.",
            "If a plant is located in the forest and it is a desert plant, then it needs sunlight."
        ],
        "premises_FOL": [
            "∀x (Plant(x) → NeedsSunlight(x)) ::: Every plant needs sunlight.",
            "∀x (Plant(x) → NeedsWater(x)) ::: Every plant needs water.",
            "∀x (¬DesertPlant(x) → Grows(x)) ::: If a plant is not a desert plant, it will grow.",
            "∃x ∃y (Plant(x) ∧ LocatedIn(x, y)) ::: Some plants are located in a forest.",
            "∀x ∀y (Contains(x, y) → Grows(x)) ::: If something contains water, it will grow.",
            "∀x (Edible(x) → ProvidesFoodFor(x, x)) ::: If something is edible, it provides food.",
            "∀x ∀y (PollinatedBy(x, y) → Produces(x, y)) ::: If something is pollinated then it produces seeds.",
            "∀x (HasFlower(x) → Grows(x)) ::: If a plant has a flower, then it will grow.",
            "∀x ∀y (IsFruitOf(x, y) → IsTree(x)) ::: If a plant produces fruit then it's a tree.",
            "∀x ∀y (Eats(x, y) → IsHerbivore(x)) ::: If an animal eats a plant then it is an herbivore.",
            "∀x ∀y (ProvidesFoodFor(x, y) → Edible(x)) ::: If a plant provides food for an animal, then it is edible.",
            "∃x HasSeeds(x) ::: A plant has seeds.",
            "∀x ((NeedsSunlight(x) ∧ NeedsWater(x) ∧ ¬DesertPlant(x)) → Grows(x)) ::: If a plant needs sunlight and water, and it is not a desert plant, then it will grow.",
            "∀x (HasSeeds(x) → HasFlower(x)) ::: If a plant has seeds then it has a flower.",
            "∀x ∀y (IsTree(x) → Produces(x, y)) ::: If something is a tree, it produces fruit.",
            "∀x ∀y (LocatedIn(x, y) ∧ DesertPlant(x) → NeedsSunlight(x)) ::: If a plant is located in the forest and it is a desert plant, then it needs sunlight."
        ],
        "predicates": [
            "Plant(x) ::: x is a plant",
            "NeedsSunlight(x) ::: x needs sunlight",
            "NeedsWater(x) ::: x needs water",
            "Grows(x) ::: x grows",
            "DesertPlant(x) ::: x is a desert plant",
            "LocatedIn(x, y) ::: x is located in y",
            "Contains(x, y) ::: x contains y",
            "Edible(x) ::: x is edible",
            "PollinatedBy(x, y) ::: x is pollinated by y",
            "HasFlower(x) ::: x has a flower",
            "IsFruitOf(x, y) ::: x is a fruit of y",
            "Eats(x, y) ::: x eats y",
            "ProvidesFoodFor(x, y) ::: x provides food for y",
            "Produces(x, y) ::: x produces y",
            "HasSeeds(x) ::: x has seeds",
            "IsTree(x) ::: x is a tree",
            "IsHerbivore(x) ::: x is an herbivore"
        ]
    },
    {
        "conclusion": "If everyone is an athlete, and John is not a student, then John is a athlete and not student.",
        "conclusion_FOL": "∀x Athlete(x) ∧ ¬Student(john) → (Athlete(john) ∧ ¬Student(john)) ::: If everyone is an athlete, and John is not a student, then John is a athlete and not student",
        "premises": [
            "Everyone is an athlete if they play a sport.",
            "John plays basketball.",
            "If someone plays basketball, and is good at basketball, then they are athlete.",
            "John is good at basketball.",
            "If someone is an athlete, they run fast.",
            "If someone runs fast, they need rest.",
            "If someone needs rest, they eats healthy.",
            "If someone eats healthy and has a team, then they win.",
            "John has a team.",
            "If someone wins, and is not injured, then they are athletic.",
            "John is not injured.",
            "If the coach of John tells him to practice, John practices.",
            "John follows instructions.",
            "If someone is tall, they have a sponsor.",
            "John is tall.",
            "If someone has a sponsor, and is in shape, then they are athletic.",
            "John is in shape.",
            "John loves sports.",
            "If someone loves sports, they are strong."
        ],
        "premises_FOL": [
            "∀x ∀y (PlaysSport(x, y) → Athlete(x)) ::: Everyone is an athlete if they play a sport",
            "PlaysSport(john, basketball) ::: John plays basketball",
            "∀x (PlaysSport(x, basketball) ∧ GoodAt(x, basketball) → Athlete(x)) ::: If someone plays basketball, and is good at basketball, then they are athlete",
            "GoodAt(john, basketball) ::: John is good at basketball",
            "∀x (Athlete(x) → RunsFast(x)) ::: If someone is an athlete, they run fast",
            "∀x (RunsFast(x) → NeedsRest(x)) ::: If someone runs fast, they need rest",
            "∀x (NeedsRest(x) → EatsHealthy(x)) ::: If someone needs rest, they eats healthy",
            "∀x ∀y (EatsHealthy(x) ∧ HasTeam(x, y) → Wins(x, y)) ::: If someone eats healthy and has a team, then they win",
            "∃y HasTeam(john, y) ::: John has a team",
            "∀x (Wins(x, y) ∧ ¬IsInjured(x) → Athlete(x)) ::: If someone wins, and is not injured, then they are athletic",
            "¬IsInjured(john) ::: John is not injured",
            "∀x ∀y (Coach(y, x) ∧ FollowsInstructions(x, y) → Practices(x, y)) ::: If the coach of John tells him to practice, John practices",
            "FollowsInstructions(john, x) ::: John follows instructions",
            "∀x (IsTall(x) → HasSponsor(x, y)) ::: If someone is tall, they have a sponsor",
            "IsTall(john) ::: John is tall",
            "∀x (HasSponsor(x, y) ∧ InShape(x) → Athlete(x)) ::: If someone has a sponsor, and is in shape, then they are athletic",
            "InShape(john) ::: John is in shape",
            "∀x Loves(john, x) ::: John loves sports",
            "∀x (Loves(x, y) → IsStrong(x)) ::: If someone loves sports, they are strong"
        ],
        "predicates": [
            "Student(x) ::: x is a student",
            "Athlete(x) ::: x is an athlete",
            "PlaysSport(x, y) ::: x plays sport y",
            "GoodAt(x, y) ::: x is good at y",
            "RunsFast(x) ::: x runs fast",
            "NeedsRest(x) ::: x needs rest",
            "EatsHealthy(x) ::: x eats healthy",
            "HasTeam(x, y) ::: x has team y",
            "Wins(x, y) ::: x wins game y",
            "IsInjured(x) ::: x is injured",
            "Coach(x, y) ::: x is coach of y",
            "FollowsInstructions(x, y) ::: x follows instructions of y",
            "John(x) ::: x is John",
            "IsTall(x) ::: x is tall",
            "HasSponsor(x, y) ::: x has sponsor y",
            "InShape(x) ::: x is in shape",
            "Practices(x, y) ::: x practices sport y",
            "Loves(x, y) ::: x loves y",
            "IsStrong(x) ::: x is strong"
        ]
    },
    {
        "conclusion": "If a cat is not a mammal, then it does not eat food.",
        "conclusion_FOL": "∀x (Cat(x) ∧ ¬Mammal(x) → ¬EatsFood(x)) ::: If a cat is not a mammal, then it does not eat food.",
        "premises": [
            "All cats are animals.",
            "All cats are carnivores.",
            "Every carnivore eats meat.",
            "Every mammal eats food.",
            "Cats are not mammals.",
            "All dogs are friendly with cats.",
            "Every cat chases a mouse.",
            "Every mouse fears every cat.",
            "Every cat hunts a mouse.",
            "All lions are cats.",
            "All lions are fast.",
            "All lions are big.",
            "Big animals live in a jungle.",
            "Cats don't live in a jungle.",
            "All cats are carnivores."
        ],
        "premises_FOL": [
            "∀x (Cat(x) → Animal(x)) ::: All cats are animals.",
            "∀x (Cat(x) → Carnivore(x)) ::: All cats are carnivores.",
            "∀x (Carnivore(x) → EatsMeat(x)) ::: Every carnivore eats meat.",
            "∀x (Mammal(x) → EatsFood(x)) ::: Every mammal eats food.",
            "∀x (Cat(x) → ¬Mammal(x)) ::: Cats are not mammals.",
            "∀x ∀y (Dog(x) → Friendly(x, y)) ::: All dogs are friendly with cats.",
            "∀x (Cat(x) → ChasesMouse(x)) ::: Every cat chases a mouse.",
            "∀x ∀y (Mouse(x) → Fears(x, y)) ::: Every mouse fears every cat.",
            "∀x ∀y (Cat(x) → Hunts(x, y)) ::: Every cat hunts a mouse.",
            "∀x (Lion(x) → Cat(x)) ::: All lions are cats.",
            "∀x (Lion(x) → Fast(x)) ::: All lions are fast.",
            "∀x (Lion(x) → Big(x)) ::: All lions are big.",
            "∀x ∀y (Big(x) → LivesIn(x, y)) ::: Big animals live in a jungle.",
            "∀x (Cat(x) → ¬LivesIn(x, Jungle)) ::: Cats don't live in a jungle.",
            "∀x (Cat(x) → Carnivore(x)) ::: All cats are carnivores."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "EatsFood(x) ::: x eats food",
            "Animal(x) ::: x is an animal",
            "Carnivore(x) ::: x is a carnivore",
            "EatsMeat(x) ::: x eats meat",
            "Dog(x) ::: x is a dog",
            "Friendly(x, y) ::: x is friendly with y",
            "ChasesMouse(x) ::: x chases a mouse",
            "Mouse(x) ::: x is a mouse",
            "Fears(x, y) ::: x fears y",
            "Hunts(x, y) ::: x hunts y",
            "Lion(x) ::: x is a lion",
            "Fast(x) ::: x is fast",
            "Big(x) ::: x is big",
            "LivesIn(x, y) ::: x lives in y"
        ]
    },
    {
        "conclusion": "If someone is a doctor, they do not go to the gym.",
        "conclusion_FOL": "∀x (Doctor(x) → ¬GoesToGym(x)) ::: If someone is a doctor, they do not go to the gym.",
        "premises": [
            "All doctors are healthy.",
            "All healthy people eat vegetables.",
            "Anyone who eats vegetables runs.",
            "Anyone who runs goes to the gym.",
            "No student goes to the gym.",
            "Everyone who studies hard is smart.",
            "All professors are smart.",
            "If someone is smart, they like Physics.",
            "If someone likes Physics, they are happy.",
            "If someone is happy, they make money.",
            "Anyone who makes money has a car.",
            "Everyone with a car plays sports.",
            "If someone plays sports, they go to the gym.",
            "Doctors work hard.",
            "Working hard mean going to the gym.",
            "All doctors are healthy.",
            "Going to gym is against doctor's regulations."
        ],
        "premises_FOL": [
            "∀x (Doctor(x) → Healthy(x)) ::: All doctors are healthy.",
            "∀x (Healthy(x) → EatsVegetables(x)) ::: All healthy people eat vegetables.",
            "∀x (EatsVegetables(x) → Runs(x)) ::: Anyone who eats vegetables runs.",
            "∀x (Runs(x) → GoesToGym(x)) ::: Anyone who runs goes to the gym.",
            "∀x (Student(x) → ¬GoesToGym(x)) ::: No student goes to the gym.",
            "∀x (StudiesHard(x) → Smart(x)) ::: Everyone who studies hard is smart.",
            "∀x (Professor(x) → Smart(x)) ::: All professors are smart.",
            "∀x (Smart(x) → Likes(x, Physics)) ::: If someone is smart, they like Physics.",
            "∀x (Likes(x, Physics) → Happy(x)) ::: If someone likes Physics, they are happy.",
            "∀x (Happy(x) → MakesMoney(x)) ::: If someone is happy, they make money.",
            "∀x (MakesMoney(x) → HasCar(x)) ::: Anyone who makes money has a car.",
            "∀x (HasCar(x) → PlaysSports(x)) ::: Everyone with a car plays sports.",
            "∀x (PlaysSports(x) → GoesToGym(x)) ::: If someone plays sports, they go to the gym.",
            "∀x (Doctor(x) → StudiesHard(x)) ::: Doctors work hard.",
            "∀x (StudiesHard(x) → GoesToGym(x)) ::: Working hard mean going to the gym.",
            "∀x (Doctor(x) → Healthy(x)) ::: All doctors are healthy.",
            "∀x (Doctor(x) → ¬GoesToGym(x)) ::: Going to gym is against doctor's regulations."
        ],
        "predicates": [
            "Doctor(x) ::: x is a doctor",
            "GoesToGym(x) ::: x goes to the gym",
            "Healthy(x) ::: x is healthy",
            "EatsVegetables(x) ::: x eats vegetables",
            "Runs(x) ::: x runs",
            "Student(x) ::: x is a student",
            "StudiesHard(x) ::: x studies hard",
            "Smart(x) ::: x is smart",
            "Professor(x) ::: x is a professor",
            "Teaches(x, y) ::: x teaches y",
            "Physics(x) ::: x is physics",
            "Likes(x, y) ::: x likes y",
            "Happy(x) ::: x is happy",
            "MakesMoney(x) ::: x makes money",
            "HasCar(x) ::: x has a car",
            "PlaysSports(x) ::: x plays sports",
            "Works(x) ::: x works"
        ]
    },
    {
        "conclusion": "If Alice knows both Bob and Carol, Alice is attending a party.",
        "conclusion_FOL": "∀x (Knows(alice, bob) ∧ Knows(alice, carol) → AttendsParty(alice)) ::: If Alice knows both Bob and Carol, Alice is attending a party.",
        "premises": [
            "Alice is friends with Bob.",
            "Alice is friends with Carol.",
            "If someone is friends with someone, they are invited to the same party.",
            "Bob is invited to the party.",
            "Carol is invited to the party.",
            "If someone is invited to a party, and knows others invited to the party, they will attend.",
            "Alice knows Bob.",
            "Alice knows Carol.",
            "If someone goes to a party, they dance.",
            "Alice goes to the party.",
            "If someone is dancing, they are happy.",
            "Alice is dancing.",
            "If someone is happy, they talks with others.",
            "Alice is happy.",
            "If someone talks to someone, they know each other.",
            "Alice talks to Bob."
        ],
        "premises_FOL": [
            "IsFriendOf(alice, bob) ::: Alice is friends with Bob.",
            "IsFriendOf(alice, carol) ::: Alice is friends with Carol.",
            "∀x ∀y (IsFriendOf(x, y) → Invited(x, party)) ::: If someone is friends with someone, they are invited to the same party.",
            "Invited(bob, party) ::: Bob is invited to the party.",
            "Invited(carol, party) ::: Carol is invited to the party.",
            "∀x (Invited(x, party) ∧ Knows(x, y) ∧ Invited(y, party) → AttendsParty(x)) ::: If someone is invited to a party, and knows others invited to the party, they will attend.",
            "Knows(alice, bob) ::: Alice knows Bob.",
            "Knows(alice, carol) ::: Alice knows Carol.",
            "∀x (AttendsParty(x) → DancesWith(x, y)) ::: If someone goes to a party, they dance.",
            "AttendsParty(alice) ::: Alice goes to the party.",
            "∀x (IsDancing(x) → IsHappy(x)) ::: If someone is dancing, they are happy.",
            "IsDancing(alice) ::: Alice is dancing.",
            "∀x (IsHappy(x) → TalksTo(x, y)) ::: If someone is happy, they talks with others.",
            "IsHappy(alice) ::: Alice is happy.",
            "∀x ∀y (TalksTo(x, y) → Knows(x, y)) ::: If someone talks to someone, they know each other.",
            "TalksTo(alice, bob) ::: Alice talks to Bob."
        ],
        "predicates": [
            "Knows(x, y) ::: x knows y",
            "AttendsParty(x) ::: x attends a party",
            "Invited(x, y) ::: x is invited to party y",
            "IsFriendOf(x, y) ::: x is a friend of y",
            "Likes(x, y) ::: x likes y",
            "WorksWith(x, y) ::: x works with y",
            "Has(x, y) ::: x has y",
            "Drinks(x, y) ::: x drinks y",
            "Brings(x, y, z) ::: x brings y to party z",
            "DancesWith(x, y) ::: x dances with y",
            "IsDancing(x) ::: x is dancing",
            "PlaysMusic(x, y) ::: x plays music y",
            "Cooks(x, y) ::: x cooks y",
            "Shares(x, y, z) ::: x shares y with z",
            "IsHappy(x) ::: x is happy",
            "TalksTo(x, y) ::: x talks to y",
            "MakesFood(x, y) ::: x makes food y"
        ]
    },
    {
        "conclusion": "Therefore, not all cats are friendly.",
        "conclusion_FOL": "¬∀x (Cat(x) → Friendly(x)) ::: Therefore, not all cats are friendly.",
        "premises": [
            "All cats are mammals.",
            "Some cats hate dogs.",
            "All dogs chase mice.",
            "All cats eat mice.",
            "If an animal hates dogs, then that animal is not friendly.",
            "If a cat chases a mouse, then it eats that mouse.",
            "A cat lives with a person.",
            "All dogs are pets.",
            "A pet is either friendly or aggressive.",
            "If a cat is friendly, then it does not chase a mouse.",
            "If a cat is not friendly, then it chases a mouse.",
            "If a cat is aggressive, then it chases a mouse.",
            "Some cats are not aggressive.",
            "If a cat is scared of a dog, then it is not friendly.",
            "If a cat runs away from a dog, then it is not friendly.",
            "Some cats are scared of dogs."
        ],
        "premises_FOL": [
            "∀x (Cat(x) → Mammal(x)) ::: All cats are mammals.",
            "∃x ∃y (Cat(x) ∧ Dog(y) ∧ Hates(x, y)) ::: Some cats hate dogs.",
            "∀x ∀y (Dog(x) ∧ Mouse(y) → Chases(x, y)) ::: All dogs chase mice.",
            "∀x ∀y (Cat(x) ∧ Mouse(y) → Eats(x, y)) ::: All cats eat mice.",
            "∀x ∀y (Hates(x, y) → ¬Friendly(x)) ::: If an animal hates dogs, then that animal is not friendly.",
            "∀x ∀y (Cat(x) ∧ Chases(x, y) → Eats(x, y)) ::: If a cat chases a mouse, then it eats that mouse.",
            "∃x ∃y (Cat(x) ∧ Person(y) ∧ LivesWith(x, y)) ::: A cat lives with a person.",
            "∀x (Dog(x) → Pet(x)) ::: All dogs are pets.",
            "∀x (Pet(x) → (Friendly(x) ∨ IsAgressive(x))) ::: A pet is either friendly or aggressive.",
            "∀x (Cat(x) ∧ Friendly(x) → ¬Chases(x, y)) ::: If a cat is friendly, then it does not chase a mouse.",
            "∀x (Cat(x) ∧ ¬Friendly(x) → Chases(x, y)) ::: If a cat is not friendly, then it chases a mouse.",
            "∀x (Cat(x) ∧ IsAgressive(x) → Chases(x, y)) ::: If a cat is aggressive, then it chases a mouse.",
            "∃x (Cat(x) ∧ ¬IsAgressive(x)) ::: Some cats are not aggressive.",
            "∀x ∀y (Cat(x) ∧ Dog(y) ∧ ScaredOf(x, y) → ¬Friendly(x)) ::: If a cat is scared of a dog, then it is not friendly.",
            "∀x ∀y (Cat(x) ∧ Dog(y) ∧ RunsAwayFrom(x, y) → ¬Friendly(x)) ::: If a cat runs away from a dog, then it is not friendly.",
            "∃x ∃y (Cat(x) ∧ Dog(y) ∧ ScaredOf(x, y)) ::: Some cats are scared of dogs."
        ],
        "predicates": [
            "Cat(x) ::: x is a cat",
            "Friendly(x) ::: x is friendly",
            "Mammal(x) ::: x is a mammal",
            "Hates(x, y) ::: x hates y",
            "Dog(x) ::: x is a dog",
            "Chases(x, y) ::: x chases y",
            "Mouse(x) ::: x is a mouse",
            "Eats(x, y) ::: x eats y",
            "LivesWith(x, y) ::: x lives with y",
            "Person(x) ::: x is a person",
            "Pet(x) ::: x is a pet",
            "Has(x, y) ::: x has y",
            "Likes(x, y) ::: x likes y",
            "ScaredOf(x, y) ::: x is scared of y",
            "RunsAwayFrom(x, y) ::: x runs away from y",
            "IsAgressive(x) ::: x is aggressive."
        ]
    },
    {
        "conclusion": "If all mammals are warm-blooded and some animals are mammals, then some animals are warm-blooded.",
        "conclusion_FOL": "∃x (Animal(x) ∧ WarmBlooded(x)) ::: Some animals are warm-blooded",
        "premises": [
            "All mammals are warm-blooded.",
            "Some animals are mammals.",
            "If something is an animal and a mammal then it eats plants.",
            "Animals that eat plants live in forests.",
            "All herbivores eat plants.",
            "If something is a carnivore then it eats meat.",
            "All mammals have fur.",
            "Animals that have fur don't migrate.",
            "If something migrates then it is not endangered.",
            "All mammals protect their young.",
            "Animals that are aquatic don't have fur.",
            "If something can fly, it has wings.",
            "If an animal is a mammal and has fur, it is not nocturnal.",
            "All reptiles are not mammals.",
            "If an animal is a mammal then it is not a reptile.",
            "If something is warm-blooded, it is an animal."
        ],
        "premises_FOL": [
            "∀x (Mammal(x) → WarmBlooded(x)) ::: All mammals are warm-blooded",
            "∃x (Animal(x) ∧ Mammal(x)) ::: Some animals are mammals",
            "∀x (Animal(x) ∧ Mammal(x) → Eats(x, Plants)) ::: If something is an animal and a mammal then it eats plants",
            "∀x (Eats(x, Plants) → LivesIn(x, Forests)) ::: Animals that eat plants live in forests",
            "∀x (Herbivore(x) → Eats(x, Plants)) ::: All herbivores eat plants",
            "∀x (Carnivore(x) → Eats(x, Meat)) ::: If something is a carnivore then it eats meat",
            "∀x (Mammal(x) → HasFur(x)) ::: All mammals have fur",
            "∀x (HasFur(x) → ¬Migrates(x)) ::: Animals that have fur don't migrate",
            "∀x (Migrates(x) → ¬IsEndangered(x)) ::: If something migrates then it is not endangered",
            "∀x (Mammal(x) → ProtectsYoung(x)) ::: All mammals protect their young",
            "∀x (IsAquatic(x) → ¬HasFur(x)) ::: Animals that are aquatic don't have fur",
            "∀x (CanFly(x) → HasWings(x)) ::: If something can fly, it has wings",
            "∀x (Mammal(x) ∧ HasFur(x) → ¬IsNocturnal(x)) ::: If an animal is a mammal and has fur, it is not nocturnal",
            "∀x (Reptile(x) → ¬Mammal(x)) ::: All reptiles are not mammals",
            "∀x (Mammal(x) → ¬Reptile(x)) ::: If an animal is a mammal then it is not a reptile",
            "∀x (WarmBlooded(x) → Animal(x)) ::: If something is warm-blooded, it is an animal"
        ],
        "predicates": [
            "Mammal(x) ::: x is a mammal",
            "WarmBlooded(x) ::: x is warm-blooded",
            "Animal(x) ::: x is an animal",
            "Eats(x, y) ::: x eats y",
            "LivesIn(x, y) ::: x lives in y",
            "IsHerbivore(x) ::: x is a herbivore",
            "IsCarnivore(x) ::: x is a carnivore",
            "HasFur(x) ::: x has fur",
            "Migrates(x) ::: x migrates",
            "IsEndangered(x) ::: x is endangered",
            "ProtectsYoung(x) ::: x protects young",
            "IsAquatic(x) ::: x is aquatic",
            "CanFly(x) ::: x can fly",
            "HasWings(x) ::: x has wings",
            "IsNocturnal(x) ::: x is nocturnal",
            "IsReptile(x) ::: x is a reptile"
        ]
    },
    {
        "conclusion": "If all scientists are curious and some curious people are successful, then some scientists are successful.",
        "conclusion_FOL": "∃x (Scientist(x) ∧ Successful(x)) ::: Some scientists are successful",
        "premises": [
            "All scientists are curious.",
            "Some curious people are successful.",
            "Anyone who publishes papers is a scientist.",
            "If someone reads a lot of books, then they are curious.",
            "Anyone who works at a university is a scientist.",
            "Those who study history are not scientists.",
            "Curious people design experiments.",
            "Anyone who designs experiments analyzes data.",
            "If someone analyzes data, they present their findings.",
            "Successful people gain funding.",
            "Anyone who teaches is curious.",
            "Those who write books are not scientists.",
            "If someone is a scientist, they attend conferences.",
            "Anyone who attends conferences collaborates with others.",
            "If someone gains funding, they are successful.",
            "If someone is successful, then they publish papers.",
            "Those who study science are scientists."
        ],
        "premises_FOL": [
            "∀x (Scientist(x) → Curious(x)) ::: All scientists are curious",
            "∃x (Curious(x) ∧ Successful(x)) ::: Some curious people are successful",
            "∀x (Publishes(x, y) → Scientist(x)) ::: Anyone who publishes papers is a scientist",
            "∀x (Reads(x, y) → Curious(x)) ::: If someone reads a lot of books, then they are curious",
            "∀x (WorksAt(x, University) → Scientist(x)) ::: Anyone who works at a university is a scientist",
            "∀x (Studies(x, History) → ¬Scientist(x)) ::: Those who study history are not scientists",
            "∀x (Curious(x) → DesignsExperiment(x)) ::: Curious people design experiments",
            "∀x (DesignsExperiment(x) → AnalyzesData(x)) ::: Anyone who designs experiments analyzes data",
            "∀x (AnalyzesData(x) → PresentsFindings(x)) ::: If someone analyzes data, they present their findings",
            "∀x (Successful(x) → GainsFunding(x)) ::: Successful people gain funding",
            "∀x (Teaches(x, y) → Curious(x)) ::: Anyone who teaches is curious",
            "∀x (WritesBook(x) → ¬Scientist(x)) ::: Those who write books are not scientists",
            "∀x (Scientist(x) → AttendsConference(x)) ::: If someone is a scientist, they attend conferences",
            "∀x (AttendsConference(x) → CollaboratesWith(x, y)) ::: Anyone who attends conferences collaborates with others",
            "∀x (GainsFunding(x) → Successful(x)) ::: If someone gains funding, they are successful",
            "∀x (Successful(x) → Publishes(x, y)) ::: If someone is successful, then they publish papers",
            "∀x (Studies(x, Science) → Scientist(x)) ::: Those who study science are scientists"
        ],
        "predicates": [
            "Scientist(x) ::: x is a scientist",
            "Curious(x) ::: x is curious",
            "Successful(x) ::: x is successful",
            "Publishes(x, y) ::: x publishes y",
            "Reads(x, y) ::: x reads y",
            "WorksAt(x, y) ::: x works at y",
            "Studies(x, y) ::: x studies y",
            "IsInnovative(x) ::: x is innovative",
            "CollaboratesWith(x, y) ::: x collaborates with y",
            "AttendsConference(x) ::: x attends conference",
            "GainsFunding(x) ::: x gains funding",
            "Teaches(x, y) ::: x teaches y",
            "WritesBook(x) ::: x writes a book",
            "DesignsExperiment(x) ::: x designs an experiment",
            "AnalyzesData(x) ::: x analyzes data",
            "PresentsFindings(x) ::: x presents findings",
            "AllScientists are curious.",
            "Some curious people are successful.",
            "Anyone who publishes papers is a scientist.",
            "If someone reads a lot of books, then they are curious.",
            "Anyone who works at a university is a scientist.",
            "Those who study history are not scientists.",
            "Curious people design experiments.",
            "Anyone who designs experiments analyzes data.",
            "If someone analyzes data, they present their findings.",
            "Successful people gain funding.",
            "Anyone who teaches is curious.",
            "Those who write books are not scientists.",
            "If someone is a scientist, they attend conferences.",
            "Anyone who attends conferences collaborates with others.",
            "If someone gains funding, they are successful.",
            "If someone is successful, then they publish papers.",
            "Those who study science are scientists."
        ]
    },
    {
        "conclusion": "If all artists are creative and some creative people are also musicians, then some artists are musicians.",
        "conclusion_FOL": "∃x (Artist(x) ∧ Musician(x)) ::: Some artists are musicians",
        "premises": [
            "All artists are creative.",
            "Some creative people are also musicians.",
            "If someone paints, they are creative.",
            "If someone writes, they are an artist.",
            "Anyone who plays a musical instrument is a musician.",
            "If someone sings, they enjoy music.",
            "People who enjoy music attend concerts.",
            "Those who study art are artists.",
            "Those who teach music are musicians.",
            "If someone composes music, they are creative.",
            "Anyone who designs things is an artist.",
            "If someone plays in a band, they are a musician.",
            "Musicians write lyrics.",
            "People who read books are creative.",
            "Creative people create sculptures.",
            "Anyone who paints pictures is an artist.",
            "Anyone who is a musician, studies art, and writes lyrics, must be an artist.",
            "Anyone who is a artist and composes music is creative."
        ],
        "premises_FOL": [
            "∀x (Artist(x) → Creative(x)) ::: All artists are creative",
            "∃x (Creative(x) ∧ Musician(x)) ::: Some creative people are also musicians",
            "∀x (Paints(x, y) → Creative(x)) ::: If someone paints, they are creative",
            "∀x (Writes(x, y) → Artist(x)) ::: If someone writes, they are an artist",
            "∀x (PlaysInstrument(x, y) → Musician(x)) ::: Anyone who plays a musical instrument is a musician",
            "∀x (Sings(x) → EnjoysMusic(x)) ::: If someone sings, they enjoy music",
            "∀x (EnjoysMusic(x) → AttendsConcerts(x)) ::: People who enjoy music attend concerts",
            "∀x (StudiesArt(x) → Artist(x)) ::: Those who study art are artists",
            "∀x (TeachesMusic(x, y) → Musician(x)) ::: Those who teach music are musicians",
            "∀x (Composes(x, y) → Creative(x)) ::: If someone composes music, they are creative",
            "∀x (Designs(x, y) → Artist(x)) ::: Anyone who designs things is an artist",
            "∀x (PlaysInBand(x, y) → Musician(x)) ::: If someone plays in a band, they are a musician",
            "∀x (Musician(x) → WritesLyrics(x, y)) ::: Musicians write lyrics",
            "∀x (ReadsBooks(x) → Creative(x)) ::: People who read books are creative",
            "∀x (Creative(x) → CreatesSculptures(x)) ::: Creative people create sculptures",
            "∀x (PaintsPictures(x, y) → Artist(x)) ::: Anyone who paints pictures is an artist",
            "∀x (Musician(x) ∧ StudiesArt(x) ∧ WritesLyrics(x, y) → Artist(x)) ::: Anyone who is a musician, studies art, and writes lyrics, must be an artist",
            "∀x (Artist(x) ∧ Composes(x, y) → Creative(x)) ::: Anyone who is a artist and composes music is creative"
        ],
        "predicates": [
            "Artist(x) ::: x is an artist",
            "Creative(x) ::: x is creative",
            "Musician(x) ::: x is a musician",
            "Paints(x, y) ::: x paints y",
            "Writes(x, y) ::: x writes y",
            "PlaysInstrument(x, y) ::: x plays instrument y",
            "Sings(x) ::: x sings",
            "EnjoysMusic(x) ::: x enjoys music",
            "AttendsConcerts(x) ::: x attends concerts",
            "StudiesArt(x) ::: x studies art",
            "TeachesMusic(x) ::: x teaches music",
            "Composes(x, y) ::: x composes y",
            "Designs(x, y) ::: x designs y",
            "PlaysInBand(x, y) ::: x plays in band y",
            "WritesLyrics(x, y) ::: x writes lyrics y",
            "ReadsBooks(x) ::: x reads books",
            "CreatesSculptures(x) ::: x creates sculptures",
            "PaintsPictures(x) ::: x paints pictures"
        ]
    },
    {
        "conclusion": "If John has a high salary and is not kind, then he will not have many friends, and will not attend parties and will be alone.",
        "conclusion_FOL": "HighSalary(john) ∧ ¬IsKind(john) → ¬HasManyFriends(john) ∧ ¬AttendsParty(john) ∧ Lonely(john) ::: If John has a high salary and is not kind, then he will not have many friends, and will not attend parties and will be alone.",
        "premises": [
            "If someone has a high salary and is not kind, they will not have many friends.",
            "John has a high salary.",
            "John is not kind.",
            "If someone does not have many friends, they will not attend parties.",
            "If someone does not attend parties, they are lonely.",
            "If someone is lonely, they travel.",
            "If someone travels, they enjoy reading.",
            "If someone enjoys reading, they buy a house.",
            "If someone buys a house, they eat healthy.",
            "If someone eats healthy, they drink coffee.",
            "John has a high salary and is not kind and does not have many friends",
            "If someone drinks coffee, they play the guitar.",
            "If someone plays the guitar, they write code.",
            "If someone writes code, they own a dog.",
            "If someone owns a dog, they watch movies.",
            "If someone watches movies, they play sports.",
            "If someone plays sports, they study."
        ],
        "premises_FOL": [
            "∀x (HighSalary(x) ∧ ¬IsKind(x) → ¬HasManyFriends(x)) ::: If someone has a high salary and is not kind, they will not have many friends.",
            "HighSalary(john) ::: John has a high salary.",
            "¬IsKind(john) ::: John is not kind.",
            "∀x (¬HasManyFriends(x) → ¬AttendsParty(x)) ::: If someone does not have many friends, they will not attend parties.",
            "∀x (¬AttendsParty(x) → Lonely(x)) ::: If someone does not attend parties, they are lonely.",
            "∀x (Lonely(x) → Travels(x)) ::: If someone is lonely, they travel.",
            "∀x (Travels(x) → EnjoysReading(x)) ::: If someone travels, they enjoy reading.",
            "∀x (EnjoysReading(x) → BuysHouse(x)) ::: If someone enjoys reading, they buy a house.",
            "∀x (BuysHouse(x) → EatsHealthy(x)) ::: If someone buys a house, they eat healthy.",
            "∀x (EatsHealthy(x) → DrinksCoffee(x)) ::: If someone eats healthy, they drink coffee.",
            "HighSalary(john) ∧ ¬IsKind(john) ∧ ¬HasManyFriends(john) ::: John has a high salary and is not kind and does not have many friends",
            "∀x (DrinksCoffee(x) → PlaysGuitar(x)) ::: If someone drinks coffee, they play the guitar.",
            "∀x (PlaysGuitar(x) → WritesCode(x)) ::: If someone plays the guitar, they write code.",
            "∀x (WritesCode(x) → OwnsDog(x)) ::: If someone writes code, they own a dog.",
            "∀x (OwnsDog(x) → WatchesMovies(x)) ::: If someone owns a dog, they watch movies.",
            "∀x (WatchesMovies(x) → PlaysSports(x)) ::: If someone watches movies, they play sports.",
            "∀x (PlaysSports(x) → Studies(x)) ::: If someone plays sports, they study."
        ],
        "predicates": [
            "HighSalary(x) ::: x has a high salary",
            "IsKind(x) ::: x is kind",
            "HasManyFriends(x) ::: x has many friends",
            "AttendsParty(x) ::: x attends a party",
            "Lonely(x) ::: x is lonely",
            "Travels(x) ::: x travels",
            "EnjoysReading(x) ::: x enjoys reading",
            "BuysHouse(x) ::: x buys a house",
            "EatsHealthy(x) ::: x eats healthy",
            "DrinksCoffee(x) ::: x drinks coffee",
            "PlaysGuitar(x) ::: x plays the guitar",
            "WritesCode(x) ::: x writes code",
            "OwnsDog(x) ::: x owns a dog",
            "WatchesMovies(x) ::: x watches movies",
            "PlaysSports(x) ::: x plays sports",
            "Studies(x) ::: x studies"
        ]
    },
    {
        "conclusion": "If a researcher publishes a paper then they will contribute to the advancement of science.",
        "conclusion_FOL": "∀x (Researcher(x) ∧ PublishesPaper(x) → ContributesToScience(x)) ::: If a researcher publishes a paper then they will contribute to the advancement of science.",
        "premises": [
            "All researchers study a field.",
            "If a researcher studies a field, they write papers about the field.",
            "If a researcher needs funding, they will receive funding if they are awarded an award.",
            "If a researcher is funded, they publish papers.",
            "Researchers often collaborate with each other.",
            "If a paper is cited, then it is peer-reviewed.",
            "If a paper is innovative, it is cited.",
            "If a paper is published, then it is cited.",
            "If a researcher attends a conference, they are awarded an award.",
            "Researchers who study a field attend seminars.",
            "Researchers who study a field attend conferences.",
            "If someone wins an award, then they are awarded an award.",
            "If a paper is peer-reviewed, then it contributes to science.",
            "If a researcher writes a paper, then he publishes the paper.",
            "If a researcher is awarded an award, they contribute to the advancement of science.",
            "If someone publishes a paper, they write a paper."
        ],
        "premises_FOL": [
            "∀x ∃y (Researcher(x) → StudiesField(x, y)) ::: All researchers study a field.",
            "∀x ∀y (Researcher(x) ∧ StudiesField(x, y) → WritesPaper(x)) ::: If a researcher studies a field, they write papers about the field.",
            "∀x (Researcher(x) ∧ NeedsFunding(x) ∧ WinsAward(x) → IsFunded(x)) ::: If a researcher needs funding, they will receive funding if they are awarded an award.",
            "∀x (Researcher(x) ∧ IsFunded(x) → PublishesPaper(x)) ::: If a researcher is funded, they publish papers.",
            "∀x ∃y CollaboratesWith(x, y) ::: Researchers often collaborate with each other.",
            "∀x ∀y (CitesPaper(x, y) → IsPeerReviewed(y)) ::: If a paper is cited, then it is peer-reviewed.",
            "∀x (IsInnovative(x) → CitesPaper(x, y)) ::: If a paper is innovative, it is cited.",
            "∀x (PublishesPaper(x) → IsCited(x)) ::: If a paper is published, then it is cited.",
            "∀x (Researcher(x) ∧ AttendsConference(x) → IsAwarded(x)) ::: If a researcher attends a conference, they are awarded an award.",
            "∀x (Researcher(x) ∧ StudiesField(x, y) → AttendsSeminar(x)) ::: Researchers who study a field attend seminars.",
            "∀x (Researcher(x) ∧ StudiesField(x, y) → AttendsConference(x)) ::: Researchers who study a field attend conferences.",
            "∀x (WinsAward(x) → IsAwarded(x)) ::: If someone wins an award, then they are awarded an award.",
            "∀x (IsPeerReviewed(x) → ContributesToScience(x)) ::: If a paper is peer-reviewed, then it contributes to science.",
            "∀x (Researcher(x) ∧ WritesPaper(x) → PublishesPaper(x)) ::: If a researcher writes a paper, then he publishes the paper.",
            "∀x (Researcher(x) ∧ IsAwarded(x) → ContributesToScience(x)) ::: If a researcher is awarded an award, they contribute to the advancement of science.",
            "∀x (PublishesPaper(x) → WritesPaper(x)) ::: If someone publishes a paper, they write a paper."
        ],
        "predicates": [
            "Researcher(x) ::: x is a researcher",
            "PublishesPaper(x) ::: x publishes a paper",
            "ContributesToScience(x) ::: x contributes to science",
            "StudiesField(x, y) ::: x studies field y",
            "GrantsFunding(x, y) ::: x grants funding to y",
            "NeedsFunding(x) ::: x needs funding",
            "IsFunded(x) ::: x is funded",
            "CollaboratesWith(x, y) ::: x collaborates with y",
            "CitesPaper(x, y) ::: x cites paper y",
            "IsPeerReviewed(x) ::: x is peer reviewed",
            "IsInnovative(x) ::: x is innovative",
            "IsCited(x) ::: x is cited",
            "WritesPaper(x) ::: x writes a paper",
            "AttendsConference(x) ::: x attends a conference",
            "IsAwarded(x) ::: x is awarded",
            "WinsAward(x) ::: x wins an award",
            "AttendsSeminar(x) ::: x attends a seminar"
        ]
    },
    {
        "conclusion": "Someone has a pet that is an animal, and that pet is owned by someone who owns a house.",
        "conclusion_FOL": "∃x ∃y ∃z (Owns(x, y) ∧ Pet(y) ∧ Animal(y) ∧ Owns(z, y) ∧ Owns(z, w) ∧ House(w)) ::: There exists a person x that owns a pet y and the pet y is an animal and there is another person z that owns the same pet y and z owns a house w.",
        "premises": [
            "All dogs are pets.",
            "All cats are pets.",
            "All dogs are animals.",
            "All cats are animals.",
            "Some people own pets.",
            "All pets that are not cats are friendly with people.",
            "Some people own houses.",
            "Some people own cats.",
            "All birds are animals.",
            "All birds are pets.",
            "All mammals are animals.",
            "All dogs are mammals.",
            "All cats live in houses.",
            "Some people live in cities.",
            "All pets are owned by people."
        ],
        "premises_FOL": [
            "∀x (Dog(x) → Pet(x)) ::: All dogs are pets",
            "∀x (Cat(x) → Pet(x)) ::: All cats are pets",
            "∀x (Dog(x) → Animal(x)) ::: All dogs are animals",
            "∀x (Cat(x) → Animal(x)) ::: All cats are animals",
            "∃x ∃y (Person(x) ∧ Owns(x, y) ∧ Pet(y)) ::: Some people own pets",
            "∀x ∀y ((Pet(x) ∧ ¬Cat(x)) → FriendlyWith(x, y)) ::: All pets that are not cats are friendly with people",
            "∃x ∃y (Person(x) ∧ Owns(x, y) ∧ House(y)) ::: Some people own houses",
            "∃x ∃y (Person(x) ∧ Owns(x, y) ∧ Cat(y)) ::: Some people own cats",
            "∀x (Bird(x) → Animal(x)) ::: All birds are animals",
            "∀x (Bird(x) → Pet(x)) ::: All birds are pets",
            "∀x (Mammal(x) → Animal(x)) ::: All mammals are animals",
            "∀x (Dog(x) → Mammal(x)) ::: All dogs are mammals",
            "∀x ∀y (Cat(x) ∧ House(y) → LivesIn(x, y)) ::: All cats live in houses",
            "∃x ∃y (Person(x) ∧ City(y) ∧ LivesIn(x, y)) ::: Some people live in cities",
            "∀x ∀y (Pet(x) ∧ Owns(z, x) → Person(z)) ::: All pets are owned by people"
        ],
        "predicates": [
            "Owns(x, y) ::: x owns y",
            "Pet(x) ::: x is a pet",
            "Animal(x) ::: x is an animal",
            "Person(x) ::: x is a person",
            "House(x) ::: x is a house",
            "Has(x, y) ::: x has y",
            "Dog(x) ::: x is a dog",
            "Cat(x) ::: x is a cat",
            "Mammal(x) ::: x is a mammal",
            "Bird(x) ::: x is a bird",
            "FriendlyWith(x, y) ::: x is friendly with y",
            "LivesIn(x, y) ::: x lives in y",
            "IsHappy(x) ::: x is happy",
            "Likes(x, y) ::: x likes y",
            "NeighborsWith(x, y) ::: x is neighbors with y",
            "City(x) ::: x is a city"
        ]
    },
    {
        "conclusion": "There exists at least one city that is both polluted and overcrowded.",
        "conclusion_FOL": "∃x (City(x) ∧ Polluted(x) ∧ Overcrowded(x)) ::: There exists a city that is polluted and overcrowded.",
        "premises": [
            "Every city is either polluted or not polluted.",
            "All cities with traffic are polluted.",
            "All cities with industry have traffic.",
            "Some cities are near the coast.",
            "All cities located in a country develop that country.",
            "All capitals are cities.",
            "Every city either has a high population or has low resources.",
            "All cities with industry produce pollution.",
            "Every city that is near the coast is a coastal city.",
            "Some cities have high population.",
            "Some cities are overcrowded.",
            "All cities with traffic are overcrowded.",
            "Some cities export goods.",
            "All cities that produce pollution are polluted.",
            "Some cities are capitals.",
            "Every coastal city is a city."
        ],
        "premises_FOL": [
            "∀x (City(x) → (Polluted(x) ∨ ¬Polluted(x))) ::: Every city is either polluted or not polluted.",
            "∀x (City(x) ∧ HasTraffic(x) → Polluted(x)) ::: All cities with traffic are polluted.",
            "∀x (City(x) ∧ HasIndustry(x) → HasTraffic(x)) ::: All cities with industry have traffic.",
            "∃x ∃y (City(x) ∧ IsNear(x, y)) ::: Some cities are near the coast.",
            "∀x ∀y (City(x) ∧ LocatedIn(x, y) → Develops(x, y)) ::: All cities located in a country develop that country.",
            "∀x (IsCapital(x) → City(x)) ::: All capitals are cities.",
            "∀x (City(x) → (HasHighPopulation(x) ∨ HasLowResources(x))) ::: Every city either has a high population or has low resources.",
            "∀x (City(x) ∧ HasIndustry(x) → ProducesPollution(x)) ::: All cities with industry produce pollution.",
            "∀x (City(x) ∧ IsNear(x, coast) → IsCoastal(x)) ::: Every city that is near the coast is a coastal city.",
            "∃x (City(x) ∧ HasHighPopulation(x)) ::: Some cities have high population.",
            "∃x (City(x) ∧ Overcrowded(x)) ::: Some cities are overcrowded.",
            "∀x (City(x) ∧ HasTraffic(x) → Overcrowded(x)) ::: All cities with traffic are overcrowded.",
            "∃x ∃y Exports(x, y) ::: Some cities export goods.",
            "∀x (City(x) ∧ ProducesPollution(x) → Polluted(x)) ::: All cities that produce pollution are polluted.",
            "∃x IsCapital(x) ::: Some cities are capitals.",
            "∀x IsCoastal(x) → City(x) ::: Every coastal city is a city."
        ],
        "predicates": [
            "City(x) ::: x is a city",
            "Polluted(x) ::: x is polluted",
            "Overcrowded(x) ::: x is overcrowded",
            "HasTraffic(x) ::: x has traffic",
            "HasIndustry(x) ::: x has industry",
            "LocatedIn(x, y) ::: x is located in y",
            "IsCapital(x) ::: x is a capital",
            "Country(x) ::: x is a country",
            "Develops(x, y) ::: x develops y",
            "Exports(x, y) ::: x exports y",
            "IsNear(x, y) ::: x is near y",
            "IsCoastal(x) ::: x is coastal",
            "Imports(x, y) ::: x imports y",
            "HasHighPopulation(x) ::: x has a high population",
            "HasLowResources(x) ::: x has low resources",
            "ProducesPollution(x) ::: x produces pollution"
        ]
    },
    {
        "conclusion": "Alice can enroll in Advanced Logic.",
        "conclusion_FOL": "CanEnroll(Alice, AdvancedLogic) ::: Alice can enroll in Advanced Logic.",
        "premises": [
            "Alice is a student.",
            "Advanced Logic is a course.",
            "Intro to Logic is a course.",
            "Advanced Logic requires a prerequisite.",
            "Intro to Logic is a prerequisite for Advanced Logic.",
            "Alice has completed Intro to Logic.",
            "The Advanced Logic course is available."
        ],
        "premises_FOL": [
            "Student(Alice) ::: Alice is a student.",
            "Course(AdvancedLogic) ::: Advanced Logic is a course.",
            "Course(IntroToLogic) ::: Intro to Logic is a course.",
            "RequiresPrerequisite(AdvancedLogic) ::: Advanced Logic requires a prerequisite.",
            "IsPrerequisiteFor(IntroToLogic, AdvancedLogic) ::: Intro to Logic is a prerequisite for Advanced Logic.",
            "HasCompleted(Alice, IntroToLogic) ::: Alice has completed Intro to Logic.",
            "CourseAvailable(AdvancedLogic) ::: The Advanced Logic course is available."
        ],
        "predicates": [
            "AffectsGPACalculation(y)",
            "AnotherPotentialAcademicIssue(x, s)",
            "CanEnroll(x, y)",
            "CanRegister(x, c, s)",
            "CompletedCourse(x, y)",
            "CompletedCourse(x, c)",
            "CompletedProject(x)",
            "CompletedThesis(x)",
            "Course(y)",
            "Course(c)",
            "CourseAvailable(y)",
            "CourseSatisfiesRequirement(c, r)",
            "EligibleToGraduate(x, m)",
            "EligibleForDegree(x, m)",
            "EnrollmentLoadBelowFullTime(x, s)",
            "FailedCourse(x, y, s)",
            "GPABelowThreshold(x, s)",
            "HasCompleted(x, z)",
            "InSemester(x, s)",
            "IsPrerequisiteFor(z, y)",
            "IsRegisteredAtTime(x, t)",
            "MajorRequirement(r, m)",
            "MajoringIn(x, m)",
            "MetCreditRequirement(x, m)",
            "MetElectiveRequirement(x, m)",
            "PlacedOnProbation(x, s)",
            "PotentialAcademicIssue(x, s)",
            "RequiredCourseForMajor(y, m)",
            "RequiresElectives(m)",
            "RequiresPrerequisite(y)",
            "RequiresThesisOrProject(m)",
            "RegistrationBlocked(x, s, r)",
            "ScheduledTime(s, t)",
            "SectionFull(s)",
            "SectionOfCourse(s, c)",
            "Student(x)",
            "WantsToRegister(x, y)",
            "WantsToRegister(x, c, s)"
        ]
    },
    {
        "conclusion": "Charlie is placed on academic probation for the Spring 2024 semester.",
        "conclusion_FOL": "PlacedOnProbation(Charlie, Spring2024) ::: Charlie is placed on academic probation for the Spring 2024 semester.",
        "premises": [
            "Charlie is a student.",
            "Charlie is in the Spring 2024 semester.",
            "Charlie failed Thermodynamics in Spring 2024.",
            "Thermodynamics is a course that affects GPA calculation.",
            "Charlie's GPA is below the threshold in Spring 2024.",
            "Charlie's enrollment load is below full-time in Spring 2024.",
            "If Charlie failed a GPA-affecting course in Spring 2024, it indicates a potential academic issue.",
            "If a student's enrollment load is below full-time in a semester, it indicates another potential academic issue.",
            "If a student has any potential academic issue in a semester and their GPA is below the threshold, they are placed on probation."
        ],
        "premises_FOL": [
            "Student(Charlie) ::: Charlie is a student.",
            "InSemester(Charlie, Spring2024) ::: Charlie is in the Spring 2024 semester.",
            "FailedCourse(Charlie, Thermodynamics, Spring2024) ::: Charlie failed Thermodynamics in Spring 2024.",
            "AffectsGPACalculation(Thermodynamics) ::: Thermodynamics is a course that affects GPA calculation.",
            "GPABelowThreshold(Charlie, Spring2024) ::: Charlie's GPA is below the threshold in Spring 2024.",
            "EnrollmentLoadBelowFullTime(Charlie, Spring2024) ::: Charlie's enrollment load is below full-time in Spring 2024.",
            "∀y (FailedCourse(Charlie, y, Spring2024) ∧ AffectsGPACalculation(y)) → PotentialAcademicIssue(Charlie, Spring2024) ::: If Charlie failed a GPA-affecting course in Spring 2024, it indicates a potential academic issue.",
            "∀x ∀s (Student(x) ∧ InSemester(x, s) ∧ EnrollmentLoadBelowFullTime(x, s)) → AnotherPotentialAcademicIssue(x, s) ::: If a student's enrollment load is below full-time in a semester, it indicates another potential academic issue.",
            "∀x ∀s (Student(x) ∧ InSemester(x, s) ∧ (PotentialAcademicIssue(x, s) ∨ AnotherPotentialAcademicIssue(x, s)) ∧ GPABelowThreshold(x, s) → PlacedOnProbation(x, s)) ::: If a student has any potential academic issue in a semester and their GPA is below the threshold, they are placed on probation."
        ],
        "predicates": [
            "AffectsGPACalculation(y)",
            "AnotherPotentialAcademicIssue(x, s)",
            "CanEnroll(x, y)",
            "CanRegister(x, c, s)",
            "CompletedCourse(x, y)",
            "CompletedCourse(x, c)",
            "CompletedProject(x)",
            "CompletedThesis(x)",
            "Course(y)",
            "Course(c)",
            "CourseAvailable(y)",
            "CourseSatisfiesRequirement(c, r)",
            "EligibleToGraduate(x, m)",
            "EligibleForDegree(x, m)",
            "EnrollmentLoadBelowFullTime(x, s)",
            "FailedCourse(x, y, s)",
            "GPABelowThreshold(x, s)",
            "HasCompleted(x, z)",
            "InSemester(x, s)",
            "IsPrerequisiteFor(z, y)",
            "IsRegisteredAtTime(x, t)",
            "MajorRequirement(r, m)",
            "MajoringIn(x, m)",
            "MetCreditRequirement(x, m)",
            "MetElectiveRequirement(x, m)",
            "PlacedOnProbation(x, s)",
            "PotentialAcademicIssue(x, s)",
            "RequiredCourseForMajor(y, m)",
            "RequiresElectives(m)",
            "RequiresPrerequisite(y)",
            "RequiresThesisOrProject(m)",
            "RegistrationBlocked(x, s, r)",
            "ScheduledTime(s, t)",
            "SectionFull(s)",
            "SectionOfCourse(s, c)",
            "Student(x)",
            "WantsToRegister(x, y)",
            "WantsToRegister(x, c, s)"
        ]
    },
    {
        "conclusion": "Dana cannot register for LA_Section1 of Linear Algebra.",
        "conclusion_FOL": "¬CanRegister(Dana, LinearAlgebra, LA_Section1) ::: Dana cannot register for LA_Section1 of Linear Algebra.",
        "premises": [
            "Dana is a student.",
            "Linear Algebra is a course.",
            "LA_Section1 is a section of Linear Algebra.",
            "Dana wants to register for LA_Section1.",
            "LA_Section1 is full.",
            "LA_Section1 is scheduled for MWF 10 AM.",
            "Dana is already registered for something at MWF 10 AM.",
            "Registration is blocked due to capacity if the section is full.",
            "Registration is blocked due to time conflict if the scheduled time conflicts with an existing registration.",
            "If registration is blocked for any reason, the student cannot register."
        ],
        "premises_FOL": [
            "Student(Dana) ::: Dana is a student.",
            "Course(LinearAlgebra) ::: Linear Algebra is a course.",
            "SectionOfCourse(LA_Section1, LinearAlgebra) ::: LA_Section1 is a section of Linear Algebra.",
            "WantsToRegister(Dana, LinearAlgebra, LA_Section1) ::: Dana wants to register for LA_Section1.",
            "SectionFull(LA_Section1) ::: LA_Section1 is full.",
            "ScheduledTime(LA_Section1, MWF_10AM) ::: LA_Section1 is scheduled for MWF 10 AM.",
            "IsRegisteredAtTime(Dana, MWF_10AM) ::: Dana is already registered for something at MWF 10 AM.",
            "∀x ∀s (Student(x) ∧ WantsToRegister(x, c, s) ∧ SectionFull(s) → RegistrationBlocked(x, s, \"Full\")) ::: Registration is blocked due to capacity if the section is full.",
            "∀x ∀s ∀t (Student(x) ∧ WantsToRegister(x, c, s) ∧ ScheduledTime(s, t) ∧ IsRegisteredAtTime(x, t) → RegistrationBlocked(x, s, \"TimeConflict\")) ::: Registration is blocked due to time conflict if the scheduled time conflicts with an existing registration.",
            "∀x ∀s ∀c (RegistrationBlocked(x, s, \"Full\") ∨ RegistrationBlocked(x, s, \"TimeConflict\") → ¬CanRegister(x, c, s)) ::: If registration is blocked for any reason, the student cannot register."
        ],
        "predicates": [
            "AffectsGPACalculation(y)",
            "AnotherPotentialAcademicIssue(x, s)",
            "CanEnroll(x, y)",
            "CanRegister(x, c, s)",
            "CompletedCourse(x, y)",
            "CompletedCourse(x, c)",
            "CompletedProject(x)",
            "CompletedThesis(x)",
            "Course(y)",
            "Course(c)",
            "CourseAvailable(y)",
            "CourseSatisfiesRequirement(c, r)",
            "EligibleToGraduate(x, m)",
            "EligibleForDegree(x, m)",
            "EnrollmentLoadBelowFullTime(x, s)",
            "FailedCourse(x, y, s)",
            "GPABelowThreshold(x, s)",
            "HasCompleted(x, z)",
            "InSemester(x, s)",
            "IsPrerequisiteFor(z, y)",
            "IsRegisteredAtTime(x, t)",
            "MajorRequirement(r, m)",
            "MajoringIn(x, m)",
            "MetCreditRequirement(x, m)",
            "MetElectiveRequirement(x, m)",
            "PlacedOnProbation(x, s)",
            "PotentialAcademicIssue(x, s)",
            "RequiredCourseForMajor(y, m)",
            "RequiresElectives(m)",
            "RequiresPrerequisite(y)",
            "RequiresThesisOrProject(m)",
            "RegistrationBlocked(x, s, r)",
            "ScheduledTime(s, t)",
            "SectionFull(s)",
            "SectionOfCourse(s, c)",
            "Student(x)",
            "WantsToRegister(x, y)",
            "WantsToRegister(x, c, s)"
        ]
    }
]